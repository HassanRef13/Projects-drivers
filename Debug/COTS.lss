
COTS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001c58  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000042  00800060  00001c58  00001cec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000690  008000a2  008000a2  00001d2e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001d2e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001d60  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000560  00000000  00000000  00001d9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005653  00000000  00000000  000022fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017da  00000000  00000000  0000794f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003268  00000000  00000000  00009129  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000efc  00000000  00000000  0000c394  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001888  00000000  00000000  0000d290  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000048de  00000000  00000000  0000eb18  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004a8  00000000  00000000  000133f6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 c7 02 	jmp	0x58e	; 0x58e <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 55 03 	jmp	0x6aa	; 0x6aa <__vector_6>
      1c:	0c 94 ca 06 	jmp	0xd94	; 0xd94 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 26 03 	jmp	0x64c	; 0x64c <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 4b 03 	jmp	0x696	; 0x696 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 ef 03 	jmp	0x7de	; 0x7de <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 18 04 	jmp	0x830	; 0x830 <__vector_15>
      40:	0c 94 f0 02 	jmp	0x5e0	; 0x5e0 <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e5       	ldi	r30, 0x58	; 88
      68:	fc e1       	ldi	r31, 0x1C	; 28
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3a       	cpi	r26, 0xA2	; 162
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a2 ea       	ldi	r26, 0xA2	; 162
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 33       	cpi	r26, 0x32	; 50
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 97 00 	call	0x12e	; 0x12e <main>
      8a:	0c 94 2a 0e 	jmp	0x1c54	; 0x1c54 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Task_1>:
{
	
	
	while (1)
	{
		PORT_Init();
      92:	0e 94 2c 04 	call	0x858	; 0x858 <PORT_Init>
		KEYPAD_init();
      96:	0e 94 cd 00 	call	0x19a	; 0x19a <KEYPAD_init>
		LCD_Init();
      9a:	0e 94 8b 01 	call	0x316	; 0x316 <LCD_Init>
		xQUEUE	= xQueueCreate(QUEUE_LENGTH , ITEM_SIZE );
      9e:	40 e0       	ldi	r20, 0x00	; 0
      a0:	64 e0       	ldi	r22, 0x04	; 4
      a2:	8a e0       	ldi	r24, 0x0A	; 10
      a4:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <xQueueGenericCreate>
      a8:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <xQUEUE+0x1>
      ac:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <xQUEUE>
		vTaskSuspend( Task_1_Hnadle );
      b0:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <Task_1_Hnadle>
      b4:	90 91 a7 00 	lds	r25, 0x00A7	; 0x8000a7 <Task_1_Hnadle+0x1>
      b8:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <vTaskSuspend>
      bc:	ea cf       	rjmp	.-44     	; 0x92 <Task_1>

000000be <Task_2>:
	}
}

void Task_2 (void* p)
{
      be:	cf 93       	push	r28
      c0:	df 93       	push	r29
      c2:	1f 92       	push	r1
      c4:	cd b7       	in	r28, 0x3d	; 61
      c6:	de b7       	in	r29, 0x3e	; 62
	uint8 var = 0;
      c8:	19 82       	std	Y+1, r1	; 0x01
	
	while (1)
	{
		var  = KeyPAD_GetValue();
      ca:	0e 94 de 00 	call	0x1bc	; 0x1bc <KeyPAD_GetValue>
      ce:	89 83       	std	Y+1, r24	; 0x01
		
		if (var !=0)
      d0:	88 23       	and	r24, r24
      d2:	61 f0       	breq	.+24     	; 0xec <Task_2+0x2e>
		{
			xQueueSend(xQUEUE,( void *) &var, ( TickType_t ) 10);
      d4:	20 e0       	ldi	r18, 0x00	; 0
      d6:	4a e0       	ldi	r20, 0x0A	; 10
      d8:	50 e0       	ldi	r21, 0x00	; 0
      da:	be 01       	movw	r22, r28
      dc:	6f 5f       	subi	r22, 0xFF	; 255
      de:	7f 4f       	sbci	r23, 0xFF	; 255
      e0:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <xQUEUE>
      e4:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <xQUEUE+0x1>
      e8:	0e 94 02 08 	call	0x1004	; 0x1004 <xQueueGenericSend>
		}
		
		vTaskDelay( 100 );
      ec:	84 e6       	ldi	r24, 0x64	; 100
      ee:	90 e0       	ldi	r25, 0x00	; 0
      f0:	0e 94 84 0c 	call	0x1908	; 0x1908 <vTaskDelay>
	}
      f4:	ea cf       	rjmp	.-44     	; 0xca <Task_2+0xc>

000000f6 <Task_3>:
}

void Task_3 (void* p)
{
      f6:	cf 93       	push	r28
      f8:	df 93       	push	r29
      fa:	1f 92       	push	r1
      fc:	cd b7       	in	r28, 0x3d	; 61
      fe:	de b7       	in	r29, 0x3e	; 62
	uint8 val =0;
     100:	19 82       	std	Y+1, r1	; 0x01
	
	while (1)
	{
		xQueueReceive (xQUEUE , &val  , 10);
     102:	4a e0       	ldi	r20, 0x0A	; 10
     104:	50 e0       	ldi	r21, 0x00	; 0
     106:	be 01       	movw	r22, r28
     108:	6f 5f       	subi	r22, 0xFF	; 255
     10a:	7f 4f       	sbci	r23, 0xFF	; 255
     10c:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <xQUEUE>
     110:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <xQUEUE+0x1>
     114:	0e 94 94 08 	call	0x1128	; 0x1128 <xQueueReceive>
		
		if (val != 0)
     118:	89 81       	ldd	r24, Y+1	; 0x01
     11a:	88 23       	and	r24, r24
     11c:	19 f0       	breq	.+6      	; 0x124 <Task_3+0x2e>
		{
			LCD_WriteChar(val);
     11e:	0e 94 a1 01 	call	0x342	; 0x342 <LCD_WriteChar>
			val=0;
     122:	19 82       	std	Y+1, r1	; 0x01
		}
		
		vTaskDelay( 50 );
     124:	82 e3       	ldi	r24, 0x32	; 50
     126:	90 e0       	ldi	r25, 0x00	; 0
     128:	0e 94 84 0c 	call	0x1908	; 0x1908 <vTaskDelay>

	}
     12c:	ea cf       	rjmp	.-44     	; 0x102 <Task_3+0xc>

0000012e <main>:



int main(void)
{
	  xTaskCreate( Task_1,
     12e:	0f 2e       	mov	r0, r31
     130:	f6 ea       	ldi	r31, 0xA6	; 166
     132:	ef 2e       	mov	r14, r31
     134:	f0 e0       	ldi	r31, 0x00	; 0
     136:	ff 2e       	mov	r15, r31
     138:	f0 2d       	mov	r31, r0
     13a:	03 e0       	ldi	r16, 0x03	; 3
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	44 e6       	ldi	r20, 0x64	; 100
     142:	50 e0       	ldi	r21, 0x00	; 0
     144:	68 e8       	ldi	r22, 0x88	; 136
     146:	70 e0       	ldi	r23, 0x00	; 0
     148:	89 e4       	ldi	r24, 0x49	; 73
     14a:	90 e0       	ldi	r25, 0x00	; 0
     14c:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xTaskCreate>
				  NULL,
				  3,
				  &Task_1_Hnadle
	  );

	 xTaskCreate(Task_2,
     150:	0f 2e       	mov	r0, r31
     152:	f4 ea       	ldi	r31, 0xA4	; 164
     154:	ef 2e       	mov	r14, r31
     156:	f0 e0       	ldi	r31, 0x00	; 0
     158:	ff 2e       	mov	r15, r31
     15a:	f0 2d       	mov	r31, r0
     15c:	02 e0       	ldi	r16, 0x02	; 2
     15e:	20 e0       	ldi	r18, 0x00	; 0
     160:	30 e0       	ldi	r19, 0x00	; 0
     162:	44 e6       	ldi	r20, 0x64	; 100
     164:	50 e0       	ldi	r21, 0x00	; 0
     166:	62 e9       	ldi	r22, 0x92	; 146
     168:	70 e0       	ldi	r23, 0x00	; 0
     16a:	8f e5       	ldi	r24, 0x5F	; 95
     16c:	90 e0       	ldi	r25, 0x00	; 0
     16e:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xTaskCreate>
				 NULL,
				 2,
				 &Task_2_Hnadle
	 );

	 xTaskCreate(Task_3,
     172:	0f 2e       	mov	r0, r31
     174:	f2 ea       	ldi	r31, 0xA2	; 162
     176:	ef 2e       	mov	r14, r31
     178:	f0 e0       	ldi	r31, 0x00	; 0
     17a:	ff 2e       	mov	r15, r31
     17c:	f0 2d       	mov	r31, r0
     17e:	01 e0       	ldi	r16, 0x01	; 1
     180:	20 e0       	ldi	r18, 0x00	; 0
     182:	30 e0       	ldi	r19, 0x00	; 0
     184:	44 e6       	ldi	r20, 0x64	; 100
     186:	50 e0       	ldi	r21, 0x00	; 0
     188:	69 e9       	ldi	r22, 0x99	; 153
     18a:	70 e0       	ldi	r23, 0x00	; 0
     18c:	8b e7       	ldi	r24, 0x7B	; 123
     18e:	90 e0       	ldi	r25, 0x00	; 0
     190:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xTaskCreate>
				 1,
				 &Task_3_Hnadle
	 );

	 // Start scheduler
	 vTaskStartScheduler();
     194:	0e 94 28 0b 	call	0x1650	; 0x1650 <vTaskStartScheduler>
     198:	ff cf       	rjmp	.-2      	; 0x198 <main+0x6a>

0000019a <KEYPAD_init>:
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK                                  
*******************************************************************************/
void  KEYPAD_init (void)
{
	DIO_WriteChannel(KEYPAD_Row0 , PIN_HIGH);
     19a:	61 e0       	ldi	r22, 0x01	; 1
     19c:	8c e0       	ldi	r24, 0x0C	; 12
     19e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(KEYPAD_Row1 , PIN_HIGH);
     1a2:	61 e0       	ldi	r22, 0x01	; 1
     1a4:	8d e0       	ldi	r24, 0x0D	; 13
     1a6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(KEYPAD_Row2 , PIN_HIGH);
     1aa:	61 e0       	ldi	r22, 0x01	; 1
     1ac:	8e e0       	ldi	r24, 0x0E	; 14
     1ae:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(KEYPAD_Row3 , PIN_HIGH);
     1b2:	61 e0       	ldi	r22, 0x01	; 1
     1b4:	8f e0       	ldi	r24, 0x0F	; 15
     1b6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
     1ba:	08 95       	ret

000001bc <KeyPAD_GetValue>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
uint8  KeyPAD_GetValue (void)
{
     1bc:	ff 92       	push	r15
     1be:	0f 93       	push	r16
     1c0:	1f 93       	push	r17
     1c2:	cf 93       	push	r28
     1c4:	df 93       	push	r29
     1c6:	1f 92       	push	r1
     1c8:	cd b7       	in	r28, 0x3d	; 61
     1ca:	de b7       	in	r29, 0x3e	; 62
	uint8 ROW_POS =0 , COL_POS =0;
	uint8 Button_Val = 0 , Temp	=	0 ;
     1cc:	19 82       	std	Y+1, r1	; 0x01
     1ce:	f1 2c       	mov	r15, r1
	
	for (ROW_POS = ROW_INIT ; ROW_POS <=ROW_FINAL ; ROW_POS ++)
     1d0:	0c e0       	ldi	r16, 0x0C	; 12
     1d2:	39 c0       	rjmp	.+114    	; 0x246 <KeyPAD_GetValue+0x8a>
	{
		DIO_WriteChannel( ROW_POS , PIN_LOW);
     1d4:	60 e0       	ldi	r22, 0x00	; 0
     1d6:	80 2f       	mov	r24, r16
     1d8:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
		for (COL_POS = COL_INIT ; COL_POS <=COL_FINAL ; COL_POS ++ )
     1dc:	1a e1       	ldi	r17, 0x1A	; 26
     1de:	2c c0       	rjmp	.+88     	; 0x238 <KeyPAD_GetValue+0x7c>
		{	
			DIO_ReadChannel(COL_POS, &Temp);	
     1e0:	be 01       	movw	r22, r28
     1e2:	6f 5f       	subi	r22, 0xFF	; 255
     1e4:	7f 4f       	sbci	r23, 0xFF	; 255
     1e6:	81 2f       	mov	r24, r17
     1e8:	0e 94 86 02 	call	0x50c	; 0x50c <DIO_ReadChannel>
			if (Temp == KEYPAD_PRESSED )
     1ec:	89 81       	ldd	r24, Y+1	; 0x01
     1ee:	81 11       	cpse	r24, r1
     1f0:	22 c0       	rjmp	.+68     	; 0x236 <KeyPAD_GetValue+0x7a>
			{
				Button_Val = KEYPAD_Values[ROW_POS - ROW_INIT][COL_POS - COL_INIT ];
     1f2:	80 2f       	mov	r24, r16
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	0c 97       	sbiw	r24, 0x0c	; 12
     1f8:	21 2f       	mov	r18, r17
     1fa:	30 e0       	ldi	r19, 0x00	; 0
     1fc:	2a 51       	subi	r18, 0x1A	; 26
     1fe:	31 09       	sbc	r19, r1
     200:	ac 01       	movw	r20, r24
     202:	44 0f       	add	r20, r20
     204:	55 1f       	adc	r21, r21
     206:	84 0f       	add	r24, r20
     208:	95 1f       	adc	r25, r21
     20a:	80 5a       	subi	r24, 0xA0	; 160
     20c:	9f 4f       	sbci	r25, 0xFF	; 255
     20e:	fc 01       	movw	r30, r24
     210:	e2 0f       	add	r30, r18
     212:	f3 1f       	adc	r31, r19
     214:	f0 80       	ld	r15, Z
				
				while (Temp == KEYPAD_PRESSED)
     216:	06 c0       	rjmp	.+12     	; 0x224 <KeyPAD_GetValue+0x68>
				{
					DIO_ReadChannel(COL_POS, &Temp);
     218:	be 01       	movw	r22, r28
     21a:	6f 5f       	subi	r22, 0xFF	; 255
     21c:	7f 4f       	sbci	r23, 0xFF	; 255
     21e:	81 2f       	mov	r24, r17
     220:	0e 94 86 02 	call	0x50c	; 0x50c <DIO_ReadChannel>
			DIO_ReadChannel(COL_POS, &Temp);	
			if (Temp == KEYPAD_PRESSED )
			{
				Button_Val = KEYPAD_Values[ROW_POS - ROW_INIT][COL_POS - COL_INIT ];
				
				while (Temp == KEYPAD_PRESSED)
     224:	89 81       	ldd	r24, Y+1	; 0x01
     226:	88 23       	and	r24, r24
     228:	b9 f3       	breq	.-18     	; 0x218 <KeyPAD_GetValue+0x5c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     22a:	8f e3       	ldi	r24, 0x3F	; 63
     22c:	9c e9       	ldi	r25, 0x9C	; 156
     22e:	01 97       	sbiw	r24, 0x01	; 1
     230:	f1 f7       	brne	.-4      	; 0x22e <KeyPAD_GetValue+0x72>
     232:	00 c0       	rjmp	.+0      	; 0x234 <KeyPAD_GetValue+0x78>
     234:	00 00       	nop
	uint8 Button_Val = 0 , Temp	=	0 ;
	
	for (ROW_POS = ROW_INIT ; ROW_POS <=ROW_FINAL ; ROW_POS ++)
	{
		DIO_WriteChannel( ROW_POS , PIN_LOW);
		for (COL_POS = COL_INIT ; COL_POS <=COL_FINAL ; COL_POS ++ )
     236:	1f 5f       	subi	r17, 0xFF	; 255
     238:	1d 31       	cpi	r17, 0x1D	; 29
     23a:	90 f2       	brcs	.-92     	; 0x1e0 <KeyPAD_GetValue+0x24>
			else 
			{
			}	
		}
		
		DIO_WriteChannel( ROW_POS , PIN_HIGH);
     23c:	61 e0       	ldi	r22, 0x01	; 1
     23e:	80 2f       	mov	r24, r16
     240:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
uint8  KeyPAD_GetValue (void)
{
	uint8 ROW_POS =0 , COL_POS =0;
	uint8 Button_Val = 0 , Temp	=	0 ;
	
	for (ROW_POS = ROW_INIT ; ROW_POS <=ROW_FINAL ; ROW_POS ++)
     244:	0f 5f       	subi	r16, 0xFF	; 255
     246:	00 31       	cpi	r16, 0x10	; 16
     248:	28 f2       	brcs	.-118    	; 0x1d4 <KeyPAD_GetValue+0x18>
		}
		
		DIO_WriteChannel( ROW_POS , PIN_HIGH);
	} 
	return Button_Val;
}
     24a:	8f 2d       	mov	r24, r15
     24c:	0f 90       	pop	r0
     24e:	df 91       	pop	r29
     250:	cf 91       	pop	r28
     252:	1f 91       	pop	r17
     254:	0f 91       	pop	r16
     256:	ff 90       	pop	r15
     258:	08 95       	ret

0000025a <LCD_WriteCommand>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteCommand(uint8 cmd)
{
     25a:	cf 93       	push	r28
     25c:	c8 2f       	mov	r28, r24
// 	uint8 old_value = 0 , New_value = 0;

	DIO_WriteChannel(LCD_RS_PIN,PIN_LOW);
     25e:	60 e0       	ldi	r22, 0x00	; 0
     260:	81 e0       	ldi	r24, 0x01	; 1
     262:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_E_PIN,PIN_LOW);
     266:	60 e0       	ldi	r22, 0x00	; 0
     268:	82 e0       	ldi	r24, 0x02	; 2
     26a:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>

	#if (LCD_MODE==LCD_4BIT_MODE)
	
	DIO_WriteChannel(LCD_D4_PIN,GET_BIT(cmd,4));	
     26e:	c4 fb       	bst	r28, 4
     270:	66 27       	eor	r22, r22
     272:	60 f9       	bld	r22, 0
     274:	83 e0       	ldi	r24, 0x03	; 3
     276:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN,GET_BIT(cmd,5));
     27a:	c5 fb       	bst	r28, 5
     27c:	66 27       	eor	r22, r22
     27e:	60 f9       	bld	r22, 0
     280:	84 e0       	ldi	r24, 0x04	; 4
     282:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN,GET_BIT(cmd,6));
     286:	c6 fb       	bst	r28, 6
     288:	66 27       	eor	r22, r22
     28a:	60 f9       	bld	r22, 0
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN,GET_BIT(cmd,7));
     292:	6c 2f       	mov	r22, r28
     294:	66 1f       	adc	r22, r22
     296:	66 27       	eor	r22, r22
     298:	66 1f       	adc	r22, r22
     29a:	86 e0       	ldi	r24, 0x06	; 6
     29c:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
// 	New_value = ((cmd>>1) & DATA_MASK) | (old_value & DATA_PORT_MASK);
// 	DIO_WritePort(LCD_D4_PIN,New_value);*/
	
	
	
	DIO_WriteChannel(LCD_E_PIN,PIN_HIGH);
     2a0:	61 e0       	ldi	r22, 0x01	; 1
     2a2:	82 e0       	ldi	r24, 0x02	; 2
     2a4:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
     2a8:	8f e9       	ldi	r24, 0x9F	; 159
     2aa:	9f e0       	ldi	r25, 0x0F	; 15
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	f1 f7       	brne	.-4      	; 0x2ac <LCD_WriteCommand+0x52>
     2b0:	00 c0       	rjmp	.+0      	; 0x2b2 <LCD_WriteCommand+0x58>
     2b2:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN,PIN_LOW);
     2b4:	60 e0       	ldi	r22, 0x00	; 0
     2b6:	82 e0       	ldi	r24, 0x02	; 2
     2b8:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_D4_PIN,GET_BIT(cmd,0));
     2bc:	6c 2f       	mov	r22, r28
     2be:	61 70       	andi	r22, 0x01	; 1
     2c0:	83 e0       	ldi	r24, 0x03	; 3
     2c2:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN,GET_BIT(cmd,1));
     2c6:	c1 fb       	bst	r28, 1
     2c8:	66 27       	eor	r22, r22
     2ca:	60 f9       	bld	r22, 0
     2cc:	84 e0       	ldi	r24, 0x04	; 4
     2ce:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN,GET_BIT(cmd,2));
     2d2:	c2 fb       	bst	r28, 2
     2d4:	66 27       	eor	r22, r22
     2d6:	60 f9       	bld	r22, 0
     2d8:	85 e0       	ldi	r24, 0x05	; 5
     2da:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN,GET_BIT(cmd,3));
     2de:	c3 fb       	bst	r28, 3
     2e0:	66 27       	eor	r22, r22
     2e2:	60 f9       	bld	r22, 0
     2e4:	86 e0       	ldi	r24, 0x06	; 6
     2e6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	New_value = ((cmd<<3)&DATA_MASK) | (old_value & DATA_PORT_MASK);
	DIO_WritePort(LCD_D4_PIN,New_value);*/
	
	
	
	DIO_WriteChannel(LCD_E_PIN,PIN_HIGH);
     2ea:	61 e0       	ldi	r22, 0x01	; 1
     2ec:	82 e0       	ldi	r24, 0x02	; 2
     2ee:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
     2f2:	8f e9       	ldi	r24, 0x9F	; 159
     2f4:	9f e0       	ldi	r25, 0x0F	; 15
     2f6:	01 97       	sbiw	r24, 0x01	; 1
     2f8:	f1 f7       	brne	.-4      	; 0x2f6 <LCD_WriteCommand+0x9c>
     2fa:	00 c0       	rjmp	.+0      	; 0x2fc <LCD_WriteCommand+0xa2>
     2fc:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN,PIN_LOW);
     2fe:	60 e0       	ldi	r22, 0x00	; 0
     300:	82 e0       	ldi	r24, 0x02	; 2
     302:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
     306:	8f e1       	ldi	r24, 0x1F	; 31
     308:	9e e4       	ldi	r25, 0x4E	; 78
     30a:	01 97       	sbiw	r24, 0x01	; 1
     30c:	f1 f7       	brne	.-4      	; 0x30a <LCD_WriteCommand+0xb0>
     30e:	00 c0       	rjmp	.+0      	; 0x310 <LCD_WriteCommand+0xb6>
     310:	00 00       	nop
	_delay_ms(5);
	
	#endif
	
}
     312:	cf 91       	pop	r28
     314:	08 95       	ret

00000316 <LCD_Init>:
*                                    E_NOT_OK                                  
*******************************************************************************/
void LCD_Init(void)
{
	#if (LCD_MODE==LCD_4BIT_MODE)
		LCD_WriteCommand(0X33);
     316:	83 e3       	ldi	r24, 0x33	; 51
     318:	0e 94 2d 01 	call	0x25a	; 0x25a <LCD_WriteCommand>
		LCD_WriteCommand(0X32);
     31c:	82 e3       	ldi	r24, 0x32	; 50
     31e:	0e 94 2d 01 	call	0x25a	; 0x25a <LCD_WriteCommand>
		LCD_WriteCommand(0X28);
     322:	88 e2       	ldi	r24, 0x28	; 40
     324:	0e 94 2d 01 	call	0x25a	; 0x25a <LCD_WriteCommand>

		LCD_WriteCommand(0X0C);
     328:	8c e0       	ldi	r24, 0x0C	; 12
     32a:	0e 94 2d 01 	call	0x25a	; 0x25a <LCD_WriteCommand>
		LCD_WriteCommand(0X01);
     32e:	81 e0       	ldi	r24, 0x01	; 1
     330:	0e 94 2d 01 	call	0x25a	; 0x25a <LCD_WriteCommand>
		
		LCD_WriteCommand(0X06);
     334:	86 e0       	ldi	r24, 0x06	; 6
     336:	0e 94 2d 01 	call	0x25a	; 0x25a <LCD_WriteCommand>
		LCD_WriteCommand(0X02);
     33a:	82 e0       	ldi	r24, 0x02	; 2
     33c:	0e 94 2d 01 	call	0x25a	; 0x25a <LCD_WriteCommand>
     340:	08 95       	ret

00000342 <LCD_WriteChar>:
* \Parameters (out): None
* \Return value:   : Std_ReturnType  E_OK
*                                    E_NOT_OK
*******************************************************************************/
void LCD_WriteChar(uint8 chr)
{
     342:	cf 93       	push	r28
     344:	c8 2f       	mov	r28, r24
// 	uint8 old_value = 0 , New_value = 0;
	DIO_WriteChannel(LCD_RS_PIN,PIN_HIGH);
     346:	61 e0       	ldi	r22, 0x01	; 1
     348:	81 e0       	ldi	r24, 0x01	; 1
     34a:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_E_PIN,PIN_LOW);
     34e:	60 e0       	ldi	r22, 0x00	; 0
     350:	82 e0       	ldi	r24, 0x02	; 2
     352:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	
	#if (LCD_MODE==LCD_4BIT_MODE)
	DIO_WriteChannel(LCD_D4_PIN,GET_BIT(chr,4));
     356:	c4 fb       	bst	r28, 4
     358:	66 27       	eor	r22, r22
     35a:	60 f9       	bld	r22, 0
     35c:	83 e0       	ldi	r24, 0x03	; 3
     35e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D5_PIN,GET_BIT(chr,5));
     362:	c5 fb       	bst	r28, 5
     364:	66 27       	eor	r22, r22
     366:	60 f9       	bld	r22, 0
     368:	84 e0       	ldi	r24, 0x04	; 4
     36a:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D6_PIN,GET_BIT(chr,6));
     36e:	c6 fb       	bst	r28, 6
     370:	66 27       	eor	r22, r22
     372:	60 f9       	bld	r22, 0
     374:	85 e0       	ldi	r24, 0x05	; 5
     376:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	DIO_WriteChannel(LCD_D7_PIN,GET_BIT(chr,7));
     37a:	6c 2f       	mov	r22, r28
     37c:	66 1f       	adc	r22, r22
     37e:	66 27       	eor	r22, r22
     380:	66 1f       	adc	r22, r22
     382:	86 e0       	ldi	r24, 0x06	; 6
     384:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	
	/*DIO_ReadOutPutPort(LCD_D4_PIN,&old_value);
	New_value= ((chr>>1)&DATA_MASK) | (old_value & DATA_PORT_MASK);
	DIO_WritePort(LCD_D4_PIN,New_value);*/
	
	DIO_WriteChannel(LCD_E_PIN,PIN_HIGH);
     388:	61 e0       	ldi	r22, 0x01	; 1
     38a:	82 e0       	ldi	r24, 0x02	; 2
     38c:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
     390:	8f e9       	ldi	r24, 0x9F	; 159
     392:	9f e0       	ldi	r25, 0x0F	; 15
     394:	01 97       	sbiw	r24, 0x01	; 1
     396:	f1 f7       	brne	.-4      	; 0x394 <LCD_WriteChar+0x52>
     398:	00 c0       	rjmp	.+0      	; 0x39a <LCD_WriteChar+0x58>
     39a:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN,PIN_LOW);
     39c:	60 e0       	ldi	r22, 0x00	; 0
     39e:	82 e0       	ldi	r24, 0x02	; 2
     3a0:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	
	/*DIO_ReadOutPutPort(LCD_D4_PIN,&old_value);
	New_value =((chr<<3)&DATA_MASK) | (old_value & DATA_PORT_MASK);
	DIO_WritePort(LCD_D4_PIN,New_value);*/
	
	DIO_WriteChannel(LCD_D4_PIN,GET_BIT(chr,0));
     3a4:	6c 2f       	mov	r22, r28
     3a6:	61 70       	andi	r22, 0x01	; 1
     3a8:	83 e0       	ldi	r24, 0x03	; 3
     3aa:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
 	DIO_WriteChannel(LCD_D5_PIN,GET_BIT(chr,1));
     3ae:	c1 fb       	bst	r28, 1
     3b0:	66 27       	eor	r22, r22
     3b2:	60 f9       	bld	r22, 0
     3b4:	84 e0       	ldi	r24, 0x04	; 4
     3b6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
 	DIO_WriteChannel(LCD_D6_PIN,GET_BIT(chr,2));
     3ba:	c2 fb       	bst	r28, 2
     3bc:	66 27       	eor	r22, r22
     3be:	60 f9       	bld	r22, 0
     3c0:	85 e0       	ldi	r24, 0x05	; 5
     3c2:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
 	DIO_WriteChannel(LCD_D7_PIN,GET_BIT(chr,3));
     3c6:	c3 fb       	bst	r28, 3
     3c8:	66 27       	eor	r22, r22
     3ca:	60 f9       	bld	r22, 0
     3cc:	86 e0       	ldi	r24, 0x06	; 6
     3ce:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
	
	DIO_WriteChannel(LCD_E_PIN,PIN_HIGH);
     3d2:	61 e0       	ldi	r22, 0x01	; 1
     3d4:	82 e0       	ldi	r24, 0x02	; 2
     3d6:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
     3da:	8f e9       	ldi	r24, 0x9F	; 159
     3dc:	9f e0       	ldi	r25, 0x0F	; 15
     3de:	01 97       	sbiw	r24, 0x01	; 1
     3e0:	f1 f7       	brne	.-4      	; 0x3de <LCD_WriteChar+0x9c>
     3e2:	00 c0       	rjmp	.+0      	; 0x3e4 <LCD_WriteChar+0xa2>
     3e4:	00 00       	nop
	_delay_ms(1);
	DIO_WriteChannel(LCD_E_PIN,PIN_LOW);
     3e6:	60 e0       	ldi	r22, 0x00	; 0
     3e8:	82 e0       	ldi	r24, 0x02	; 2
     3ea:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIO_WriteChannel>
     3ee:	8f e1       	ldi	r24, 0x1F	; 31
     3f0:	9e e4       	ldi	r25, 0x4E	; 78
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	f1 f7       	brne	.-4      	; 0x3f2 <LCD_WriteChar+0xb0>
     3f6:	00 c0       	rjmp	.+0      	; 0x3f8 <LCD_WriteChar+0xb6>
     3f8:	00 00       	nop
	_delay_ms(5);
	
	#endif
}
     3fa:	cf 91       	pop	r28
     3fc:	08 95       	ret

000003fe <DIO_WriteChannel>:
*******************************************************************************/
void DIO_WriteChannel(uint8 Pin_Num , PIN_VALUE_t Pin_value )
{
	uint8 Port = 0 , Pin = 0;
	
	Port = Pin_Num / NUMBER_OF_EACH_PORT_PINS ;
     3fe:	98 2f       	mov	r25, r24
     400:	96 95       	lsr	r25
     402:	96 95       	lsr	r25
     404:	96 95       	lsr	r25
	Pin  = Pin_Num % NUMBER_OF_EACH_PORT_PINS ;
     406:	87 70       	andi	r24, 0x07	; 7
	
	switch(Pin_value)
     408:	66 23       	and	r22, r22
     40a:	09 f4       	brne	.+2      	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
     40c:	3f c0       	rjmp	.+126    	; 0x48c <__EEPROM_REGION_LENGTH__+0x8c>
     40e:	61 30       	cpi	r22, 0x01	; 1
     410:	09 f0       	breq	.+2      	; 0x414 <__EEPROM_REGION_LENGTH__+0x14>
     412:	7b c0       	rjmp	.+246    	; 0x50a <__EEPROM_REGION_LENGTH__+0x10a>
	{
		case PIN_HIGH :
		
			switch(Port)
     414:	91 30       	cpi	r25, 0x01	; 1
     416:	99 f0       	breq	.+38     	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
     418:	28 f0       	brcs	.+10     	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
     41a:	92 30       	cpi	r25, 0x02	; 2
     41c:	e9 f0       	breq	.+58     	; 0x458 <__EEPROM_REGION_LENGTH__+0x58>
     41e:	93 30       	cpi	r25, 0x03	; 3
     420:	41 f1       	breq	.+80     	; 0x472 <__EEPROM_REGION_LENGTH__+0x72>
     422:	08 95       	ret
			{
			case 0:
			SET_BIT(PHYSICAL_GPIO_ACCESS(GPIOA_BASE_ADDRRESS + GPIO_OUTPUT_REGISTER_PORT) ,Pin );
     424:	4b b3       	in	r20, 0x1b	; 27
     426:	21 e0       	ldi	r18, 0x01	; 1
     428:	30 e0       	ldi	r19, 0x00	; 0
     42a:	b9 01       	movw	r22, r18
     42c:	02 c0       	rjmp	.+4      	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>
     42e:	66 0f       	add	r22, r22
     430:	77 1f       	adc	r23, r23
     432:	8a 95       	dec	r24
     434:	e2 f7       	brpl	.-8      	; 0x42e <__EEPROM_REGION_LENGTH__+0x2e>
     436:	cb 01       	movw	r24, r22
     438:	84 2b       	or	r24, r20
     43a:	8b bb       	out	0x1b, r24	; 27
			break;
     43c:	08 95       	ret
			
			case 1:
			SET_BIT(PHYSICAL_GPIO_ACCESS(GPIOB_BASE_ADDRRESS + GPIO_OUTPUT_REGISTER_PORT) ,Pin );
     43e:	48 b3       	in	r20, 0x18	; 24
     440:	21 e0       	ldi	r18, 0x01	; 1
     442:	30 e0       	ldi	r19, 0x00	; 0
     444:	b9 01       	movw	r22, r18
     446:	02 c0       	rjmp	.+4      	; 0x44c <__EEPROM_REGION_LENGTH__+0x4c>
     448:	66 0f       	add	r22, r22
     44a:	77 1f       	adc	r23, r23
     44c:	8a 95       	dec	r24
     44e:	e2 f7       	brpl	.-8      	; 0x448 <__EEPROM_REGION_LENGTH__+0x48>
     450:	cb 01       	movw	r24, r22
     452:	84 2b       	or	r24, r20
     454:	88 bb       	out	0x18, r24	; 24
			break;
     456:	08 95       	ret
			
			case 2:
			SET_BIT(PHYSICAL_GPIO_ACCESS(GPIOC_BASE_ADDRRESS + GPIO_OUTPUT_REGISTER_PORT) ,Pin );
     458:	45 b3       	in	r20, 0x15	; 21
     45a:	21 e0       	ldi	r18, 0x01	; 1
     45c:	30 e0       	ldi	r19, 0x00	; 0
     45e:	b9 01       	movw	r22, r18
     460:	02 c0       	rjmp	.+4      	; 0x466 <__EEPROM_REGION_LENGTH__+0x66>
     462:	66 0f       	add	r22, r22
     464:	77 1f       	adc	r23, r23
     466:	8a 95       	dec	r24
     468:	e2 f7       	brpl	.-8      	; 0x462 <__EEPROM_REGION_LENGTH__+0x62>
     46a:	cb 01       	movw	r24, r22
     46c:	84 2b       	or	r24, r20
     46e:	85 bb       	out	0x15, r24	; 21
			break;
     470:	08 95       	ret
			
			case 3:
			SET_BIT(PHYSICAL_GPIO_ACCESS(GPIOD_BASE_ADDRRESS + GPIO_OUTPUT_REGISTER_PORT) ,Pin );
     472:	42 b3       	in	r20, 0x12	; 18
     474:	21 e0       	ldi	r18, 0x01	; 1
     476:	30 e0       	ldi	r19, 0x00	; 0
     478:	b9 01       	movw	r22, r18
     47a:	02 c0       	rjmp	.+4      	; 0x480 <__EEPROM_REGION_LENGTH__+0x80>
     47c:	66 0f       	add	r22, r22
     47e:	77 1f       	adc	r23, r23
     480:	8a 95       	dec	r24
     482:	e2 f7       	brpl	.-8      	; 0x47c <__EEPROM_REGION_LENGTH__+0x7c>
     484:	cb 01       	movw	r24, r22
     486:	84 2b       	or	r24, r20
     488:	82 bb       	out	0x12, r24	; 18
			break;
     48a:	08 95       	ret
			break;
			}
			break;
		case PIN_LOW :
				
		switch(Port)
     48c:	91 30       	cpi	r25, 0x01	; 1
     48e:	a1 f0       	breq	.+40     	; 0x4b8 <__EEPROM_REGION_LENGTH__+0xb8>
     490:	28 f0       	brcs	.+10     	; 0x49c <__EEPROM_REGION_LENGTH__+0x9c>
     492:	92 30       	cpi	r25, 0x02	; 2
     494:	f9 f0       	breq	.+62     	; 0x4d4 <__EEPROM_REGION_LENGTH__+0xd4>
     496:	93 30       	cpi	r25, 0x03	; 3
     498:	59 f1       	breq	.+86     	; 0x4f0 <__EEPROM_REGION_LENGTH__+0xf0>
     49a:	08 95       	ret
		{
			case 0:
			CLR_BIT(PHYSICAL_GPIO_ACCESS(GPIOA_BASE_ADDRRESS + GPIO_OUTPUT_REGISTER_PORT) ,Pin );
     49c:	4b b3       	in	r20, 0x1b	; 27
     49e:	21 e0       	ldi	r18, 0x01	; 1
     4a0:	30 e0       	ldi	r19, 0x00	; 0
     4a2:	b9 01       	movw	r22, r18
     4a4:	02 c0       	rjmp	.+4      	; 0x4aa <__EEPROM_REGION_LENGTH__+0xaa>
     4a6:	66 0f       	add	r22, r22
     4a8:	77 1f       	adc	r23, r23
     4aa:	8a 95       	dec	r24
     4ac:	e2 f7       	brpl	.-8      	; 0x4a6 <__EEPROM_REGION_LENGTH__+0xa6>
     4ae:	cb 01       	movw	r24, r22
     4b0:	80 95       	com	r24
     4b2:	84 23       	and	r24, r20
     4b4:	8b bb       	out	0x1b, r24	; 27
			break;
     4b6:	08 95       	ret
			
			case 1:
			CLR_BIT(PHYSICAL_GPIO_ACCESS(GPIOB_BASE_ADDRRESS + GPIO_OUTPUT_REGISTER_PORT) ,Pin );
     4b8:	48 b3       	in	r20, 0x18	; 24
     4ba:	21 e0       	ldi	r18, 0x01	; 1
     4bc:	30 e0       	ldi	r19, 0x00	; 0
     4be:	b9 01       	movw	r22, r18
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__EEPROM_REGION_LENGTH__+0xc6>
     4c2:	66 0f       	add	r22, r22
     4c4:	77 1f       	adc	r23, r23
     4c6:	8a 95       	dec	r24
     4c8:	e2 f7       	brpl	.-8      	; 0x4c2 <__EEPROM_REGION_LENGTH__+0xc2>
     4ca:	cb 01       	movw	r24, r22
     4cc:	80 95       	com	r24
     4ce:	84 23       	and	r24, r20
     4d0:	88 bb       	out	0x18, r24	; 24
			break;
     4d2:	08 95       	ret
			
			case 2:
			CLR_BIT(PHYSICAL_GPIO_ACCESS(GPIOC_BASE_ADDRRESS + GPIO_OUTPUT_REGISTER_PORT) ,Pin );
     4d4:	45 b3       	in	r20, 0x15	; 21
     4d6:	21 e0       	ldi	r18, 0x01	; 1
     4d8:	30 e0       	ldi	r19, 0x00	; 0
     4da:	b9 01       	movw	r22, r18
     4dc:	02 c0       	rjmp	.+4      	; 0x4e2 <__EEPROM_REGION_LENGTH__+0xe2>
     4de:	66 0f       	add	r22, r22
     4e0:	77 1f       	adc	r23, r23
     4e2:	8a 95       	dec	r24
     4e4:	e2 f7       	brpl	.-8      	; 0x4de <__EEPROM_REGION_LENGTH__+0xde>
     4e6:	cb 01       	movw	r24, r22
     4e8:	80 95       	com	r24
     4ea:	84 23       	and	r24, r20
     4ec:	85 bb       	out	0x15, r24	; 21
			break;
     4ee:	08 95       	ret
			
			case 3:
			CLR_BIT(PHYSICAL_GPIO_ACCESS(GPIOD_BASE_ADDRRESS + GPIO_OUTPUT_REGISTER_PORT) ,Pin );
     4f0:	42 b3       	in	r20, 0x12	; 18
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	30 e0       	ldi	r19, 0x00	; 0
     4f6:	b9 01       	movw	r22, r18
     4f8:	02 c0       	rjmp	.+4      	; 0x4fe <__EEPROM_REGION_LENGTH__+0xfe>
     4fa:	66 0f       	add	r22, r22
     4fc:	77 1f       	adc	r23, r23
     4fe:	8a 95       	dec	r24
     500:	e2 f7       	brpl	.-8      	; 0x4fa <__EEPROM_REGION_LENGTH__+0xfa>
     502:	cb 01       	movw	r24, r22
     504:	80 95       	com	r24
     506:	84 23       	and	r24, r20
     508:	82 bb       	out	0x12, r24	; 18
     50a:	08 95       	ret

0000050c <DIO_ReadChannel>:
*                                    E_NOT_OK
*******************************************************************************/
void DIO_ReadChannel(uint8 Pin_Num , PIN_VALUE_t * Pin_value )
{
	uint8 Port = 0 , Pin = 0;
	Port = Pin_Num / NUMBER_OF_EACH_PORT_PINS ;
     50c:	98 2f       	mov	r25, r24
     50e:	96 95       	lsr	r25
     510:	96 95       	lsr	r25
     512:	96 95       	lsr	r25
	Pin  = Pin_Num % NUMBER_OF_EACH_PORT_PINS ;
     514:	87 70       	andi	r24, 0x07	; 7
	
	switch(Port)
     516:	91 30       	cpi	r25, 0x01	; 1
     518:	99 f0       	breq	.+38     	; 0x540 <DIO_ReadChannel+0x34>
     51a:	28 f0       	brcs	.+10     	; 0x526 <DIO_ReadChannel+0x1a>
     51c:	92 30       	cpi	r25, 0x02	; 2
     51e:	e9 f0       	breq	.+58     	; 0x55a <DIO_ReadChannel+0x4e>
     520:	93 30       	cpi	r25, 0x03	; 3
     522:	41 f1       	breq	.+80     	; 0x574 <DIO_ReadChannel+0x68>
     524:	08 95       	ret
	{
	 case 0:
	 *Pin_value = GET_BIT(PHYSICAL_GPIO_ACCESS(GPIOA_BASE_ADDRRESS + GPIO_INPUT_REGISTER_PIN) ,Pin );
     526:	29 b3       	in	r18, 0x19	; 25
     528:	30 e0       	ldi	r19, 0x00	; 0
     52a:	a9 01       	movw	r20, r18
     52c:	02 c0       	rjmp	.+4      	; 0x532 <DIO_ReadChannel+0x26>
     52e:	55 95       	asr	r21
     530:	47 95       	ror	r20
     532:	8a 95       	dec	r24
     534:	e2 f7       	brpl	.-8      	; 0x52e <DIO_ReadChannel+0x22>
     536:	ca 01       	movw	r24, r20
     538:	81 70       	andi	r24, 0x01	; 1
     53a:	fb 01       	movw	r30, r22
     53c:	80 83       	st	Z, r24
	 break;
     53e:	08 95       	ret
	 
	 case 1:
	 *Pin_value = GET_BIT(PHYSICAL_GPIO_ACCESS(GPIOB_BASE_ADDRRESS + GPIO_INPUT_REGISTER_PIN) ,Pin );
     540:	26 b3       	in	r18, 0x16	; 22
     542:	30 e0       	ldi	r19, 0x00	; 0
     544:	a9 01       	movw	r20, r18
     546:	02 c0       	rjmp	.+4      	; 0x54c <DIO_ReadChannel+0x40>
     548:	55 95       	asr	r21
     54a:	47 95       	ror	r20
     54c:	8a 95       	dec	r24
     54e:	e2 f7       	brpl	.-8      	; 0x548 <DIO_ReadChannel+0x3c>
     550:	ca 01       	movw	r24, r20
     552:	81 70       	andi	r24, 0x01	; 1
     554:	fb 01       	movw	r30, r22
     556:	80 83       	st	Z, r24
	 break;
     558:	08 95       	ret
	 
	 case 2:
	 *Pin_value = GET_BIT(PHYSICAL_GPIO_ACCESS(GPIOC_BASE_ADDRRESS + GPIO_INPUT_REGISTER_PIN) ,Pin );
     55a:	23 b3       	in	r18, 0x13	; 19
     55c:	30 e0       	ldi	r19, 0x00	; 0
     55e:	a9 01       	movw	r20, r18
     560:	02 c0       	rjmp	.+4      	; 0x566 <DIO_ReadChannel+0x5a>
     562:	55 95       	asr	r21
     564:	47 95       	ror	r20
     566:	8a 95       	dec	r24
     568:	e2 f7       	brpl	.-8      	; 0x562 <DIO_ReadChannel+0x56>
     56a:	ca 01       	movw	r24, r20
     56c:	81 70       	andi	r24, 0x01	; 1
     56e:	fb 01       	movw	r30, r22
     570:	80 83       	st	Z, r24
	 break;
     572:	08 95       	ret
	 
	 case 3:
	 *Pin_value = GET_BIT(PHYSICAL_GPIO_ACCESS(GPIOD_BASE_ADDRRESS + GPIO_INPUT_REGISTER_PIN) ,Pin );
     574:	20 b3       	in	r18, 0x10	; 16
     576:	30 e0       	ldi	r19, 0x00	; 0
     578:	a9 01       	movw	r20, r18
     57a:	02 c0       	rjmp	.+4      	; 0x580 <DIO_ReadChannel+0x74>
     57c:	55 95       	asr	r21
     57e:	47 95       	ror	r20
     580:	8a 95       	dec	r24
     582:	e2 f7       	brpl	.-8      	; 0x57c <DIO_ReadChannel+0x70>
     584:	ca 01       	movw	r24, r20
     586:	81 70       	andi	r24, 0x01	; 1
     588:	fb 01       	movw	r30, r22
     58a:	80 83       	st	Z, r24
     58c:	08 95       	ret

0000058e <__vector_1>:
	CallBack_PtrFunc[Interrupt_Vector_Index] = p;
}

/********** external INT ************/
ISR(INT0_vect)
{
     58e:	1f 92       	push	r1
     590:	0f 92       	push	r0
     592:	0f b6       	in	r0, 0x3f	; 63
     594:	0f 92       	push	r0
     596:	11 24       	eor	r1, r1
     598:	2f 93       	push	r18
     59a:	3f 93       	push	r19
     59c:	4f 93       	push	r20
     59e:	5f 93       	push	r21
     5a0:	6f 93       	push	r22
     5a2:	7f 93       	push	r23
     5a4:	8f 93       	push	r24
     5a6:	9f 93       	push	r25
     5a8:	af 93       	push	r26
     5aa:	bf 93       	push	r27
     5ac:	ef 93       	push	r30
     5ae:	ff 93       	push	r31
	if (CallBack_PtrFunc[External_Interrupt_Request_0_VECTOR_INDEX] != Null)
     5b0:	e0 91 be 00 	lds	r30, 0x00BE	; 0x8000be <CallBack_PtrFunc>
     5b4:	f0 91 bf 00 	lds	r31, 0x00BF	; 0x8000bf <CallBack_PtrFunc+0x1>
     5b8:	30 97       	sbiw	r30, 0x00	; 0
     5ba:	09 f0       	breq	.+2      	; 0x5be <__vector_1+0x30>
	{
		(*CallBack_PtrFunc[External_Interrupt_Request_0_VECTOR_INDEX])();
     5bc:	09 95       	icall
	}
}
     5be:	ff 91       	pop	r31
     5c0:	ef 91       	pop	r30
     5c2:	bf 91       	pop	r27
     5c4:	af 91       	pop	r26
     5c6:	9f 91       	pop	r25
     5c8:	8f 91       	pop	r24
     5ca:	7f 91       	pop	r23
     5cc:	6f 91       	pop	r22
     5ce:	5f 91       	pop	r21
     5d0:	4f 91       	pop	r20
     5d2:	3f 91       	pop	r19
     5d4:	2f 91       	pop	r18
     5d6:	0f 90       	pop	r0
     5d8:	0f be       	out	0x3f, r0	; 63
     5da:	0f 90       	pop	r0
     5dc:	1f 90       	pop	r1
     5de:	18 95       	reti

000005e0 <__vector_16>:

/*********** ADC *****************/
ISR(ADC_vect)
{
     5e0:	1f 92       	push	r1
     5e2:	0f 92       	push	r0
     5e4:	0f b6       	in	r0, 0x3f	; 63
     5e6:	0f 92       	push	r0
     5e8:	11 24       	eor	r1, r1
     5ea:	2f 93       	push	r18
     5ec:	3f 93       	push	r19
     5ee:	4f 93       	push	r20
     5f0:	5f 93       	push	r21
     5f2:	6f 93       	push	r22
     5f4:	7f 93       	push	r23
     5f6:	8f 93       	push	r24
     5f8:	9f 93       	push	r25
     5fa:	af 93       	push	r26
     5fc:	bf 93       	push	r27
     5fe:	ef 93       	push	r30
     600:	ff 93       	push	r31
		uint32 ADC_Digital_Value=0;
		ADC_Digital_Value=ADC_input_16bit_Access;
     602:	24 b1       	in	r18, 0x04	; 4
     604:	35 b1       	in	r19, 0x05	; 5
		ADC_Vin_Value= ((ADC_Digital_Value *5000) / 1023);
     606:	a8 e8       	ldi	r26, 0x88	; 136
     608:	b3 e1       	ldi	r27, 0x13	; 19
     60a:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <__umulhisi3>
     60e:	2f ef       	ldi	r18, 0xFF	; 255
     610:	33 e0       	ldi	r19, 0x03	; 3
     612:	40 e0       	ldi	r20, 0x00	; 0
     614:	50 e0       	ldi	r21, 0x00	; 0
     616:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <__udivmodsi4>
     61a:	20 93 aa 00 	sts	0x00AA, r18	; 0x8000aa <ADC_Vin_Value>
     61e:	30 93 ab 00 	sts	0x00AB, r19	; 0x8000ab <ADC_Vin_Value+0x1>
     622:	40 93 ac 00 	sts	0x00AC, r20	; 0x8000ac <ADC_Vin_Value+0x2>
     626:	50 93 ad 00 	sts	0x00AD, r21	; 0x8000ad <ADC_Vin_Value+0x3>
}
     62a:	ff 91       	pop	r31
     62c:	ef 91       	pop	r30
     62e:	bf 91       	pop	r27
     630:	af 91       	pop	r26
     632:	9f 91       	pop	r25
     634:	8f 91       	pop	r24
     636:	7f 91       	pop	r23
     638:	6f 91       	pop	r22
     63a:	5f 91       	pop	r21
     63c:	4f 91       	pop	r20
     63e:	3f 91       	pop	r19
     640:	2f 91       	pop	r18
     642:	0f 90       	pop	r0
     644:	0f be       	out	0x3f, r0	; 63
     646:	0f 90       	pop	r0
     648:	1f 90       	pop	r1
     64a:	18 95       	reti

0000064c <__vector_9>:

/************ Timer1 overflow flag********/
ISR(TIMER1_OVF_vect)
{
     64c:	1f 92       	push	r1
     64e:	0f 92       	push	r0
     650:	0f b6       	in	r0, 0x3f	; 63
     652:	0f 92       	push	r0
     654:	11 24       	eor	r1, r1
     656:	8f 93       	push	r24
     658:	9f 93       	push	r25
     65a:	af 93       	push	r26
     65c:	bf 93       	push	r27
	Time1_OVF_g++;
     65e:	80 91 e6 00 	lds	r24, 0x00E6	; 0x8000e6 <Time1_OVF_g>
     662:	90 91 e7 00 	lds	r25, 0x00E7	; 0x8000e7 <Time1_OVF_g+0x1>
     666:	a0 91 e8 00 	lds	r26, 0x00E8	; 0x8000e8 <Time1_OVF_g+0x2>
     66a:	b0 91 e9 00 	lds	r27, 0x00E9	; 0x8000e9 <Time1_OVF_g+0x3>
     66e:	01 96       	adiw	r24, 0x01	; 1
     670:	a1 1d       	adc	r26, r1
     672:	b1 1d       	adc	r27, r1
     674:	80 93 e6 00 	sts	0x00E6, r24	; 0x8000e6 <Time1_OVF_g>
     678:	90 93 e7 00 	sts	0x00E7, r25	; 0x8000e7 <Time1_OVF_g+0x1>
     67c:	a0 93 e8 00 	sts	0x00E8, r26	; 0x8000e8 <Time1_OVF_g+0x2>
     680:	b0 93 e9 00 	sts	0x00E9, r27	; 0x8000e9 <Time1_OVF_g+0x3>
}
     684:	bf 91       	pop	r27
     686:	af 91       	pop	r26
     688:	9f 91       	pop	r25
     68a:	8f 91       	pop	r24
     68c:	0f 90       	pop	r0
     68e:	0f be       	out	0x3f, r0	; 63
     690:	0f 90       	pop	r0
     692:	1f 90       	pop	r1
     694:	18 95       	reti

00000696 <__vector_11>:

/********* Timer0 overflow flag	********/
ISR(TIMER0_OVF_vect)
{
     696:	1f 92       	push	r1
     698:	0f 92       	push	r0
     69a:	0f b6       	in	r0, 0x3f	; 63
     69c:	0f 92       	push	r0
     69e:	11 24       	eor	r1, r1
			(*CallBack_PtrFunc[Timer_Counter0_Overflow_VECTOR_INDEX])();
			ctr =0 ;
			TCNT0 = Time0_Init_value_g;
		}
	}
}
     6a0:	0f 90       	pop	r0
     6a2:	0f be       	out	0x3f, r0	; 63
     6a4:	0f 90       	pop	r0
     6a6:	1f 90       	pop	r1
     6a8:	18 95       	reti

000006aa <__vector_6>:
// 		Counter =0 ;
// 	}
// }

ISR(TIMER1_CAPT_vect)
{	
     6aa:	1f 92       	push	r1
     6ac:	0f 92       	push	r0
     6ae:	0f b6       	in	r0, 0x3f	; 63
     6b0:	0f 92       	push	r0
     6b2:	11 24       	eor	r1, r1
     6b4:	2f 93       	push	r18
     6b6:	3f 93       	push	r19
     6b8:	4f 93       	push	r20
     6ba:	5f 93       	push	r21
     6bc:	6f 93       	push	r22
     6be:	7f 93       	push	r23
     6c0:	8f 93       	push	r24
     6c2:	9f 93       	push	r25
     6c4:	af 93       	push	r26
     6c6:	bf 93       	push	r27
     6c8:	ef 93       	push	r30
     6ca:	ff 93       	push	r31
	ICU_Cnt++;
     6cc:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <ICU_Cnt>
     6d0:	90 91 b3 00 	lds	r25, 0x00B3	; 0x8000b3 <ICU_Cnt+0x1>
     6d4:	a0 91 b4 00 	lds	r26, 0x00B4	; 0x8000b4 <ICU_Cnt+0x2>
     6d8:	b0 91 b5 00 	lds	r27, 0x00B5	; 0x8000b5 <ICU_Cnt+0x3>
     6dc:	01 96       	adiw	r24, 0x01	; 1
     6de:	a1 1d       	adc	r26, r1
     6e0:	b1 1d       	adc	r27, r1
     6e2:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <ICU_Cnt>
     6e6:	90 93 b3 00 	sts	0x00B3, r25	; 0x8000b3 <ICU_Cnt+0x1>
     6ea:	a0 93 b4 00 	sts	0x00B4, r26	; 0x8000b4 <ICU_Cnt+0x2>
     6ee:	b0 93 b5 00 	sts	0x00B5, r27	; 0x8000b5 <ICU_Cnt+0x3>
	if(ICU_Cnt ==	1)
     6f2:	81 30       	cpi	r24, 0x01	; 1
     6f4:	91 05       	cpc	r25, r1
     6f6:	a1 05       	cpc	r26, r1
     6f8:	b1 05       	cpc	r27, r1
     6fa:	c1 f4       	brne	.+48     	; 0x72c <__vector_6+0x82>
	{
		CAP1 = ICR1_16Bit_Access;
     6fc:	86 b5       	in	r24, 0x26	; 38
     6fe:	97 b5       	in	r25, 0x27	; 39
     700:	a0 e0       	ldi	r26, 0x00	; 0
     702:	b0 e0       	ldi	r27, 0x00	; 0
     704:	80 93 ba 00 	sts	0x00BA, r24	; 0x8000ba <CAP1>
     708:	90 93 bb 00 	sts	0x00BB, r25	; 0x8000bb <CAP1+0x1>
     70c:	a0 93 bc 00 	sts	0x00BC, r26	; 0x8000bc <CAP1+0x2>
     710:	b0 93 bd 00 	sts	0x00BD, r27	; 0x8000bd <CAP1+0x3>
		Time1_OVF_g=0;
     714:	10 92 e6 00 	sts	0x00E6, r1	; 0x8000e6 <Time1_OVF_g>
     718:	10 92 e7 00 	sts	0x00E7, r1	; 0x8000e7 <Time1_OVF_g+0x1>
     71c:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <Time1_OVF_g+0x2>
     720:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <Time1_OVF_g+0x3>
		/********* Falling eadge ******/
		CLR_BIT(TCCR1B, 6);
     724:	8e b5       	in	r24, 0x2e	; 46
     726:	8f 7b       	andi	r24, 0xBF	; 191
     728:	8e bd       	out	0x2e, r24	; 46
     72a:	48 c0       	rjmp	.+144    	; 0x7bc <__vector_6+0x112>
	}
	else if (ICU_Cnt ==	2)
     72c:	82 30       	cpi	r24, 0x02	; 2
     72e:	91 05       	cpc	r25, r1
     730:	a1 05       	cpc	r26, r1
     732:	b1 05       	cpc	r27, r1
     734:	01 f5       	brne	.+64     	; 0x776 <__vector_6+0xcc>
	{
		CAP2= ICR1_16Bit_Access	+	(Time1_OVF_g * 65535);
     736:	e6 b5       	in	r30, 0x26	; 38
     738:	f7 b5       	in	r31, 0x27	; 39
     73a:	20 91 e6 00 	lds	r18, 0x00E6	; 0x8000e6 <Time1_OVF_g>
     73e:	30 91 e7 00 	lds	r19, 0x00E7	; 0x8000e7 <Time1_OVF_g+0x1>
     742:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <Time1_OVF_g+0x2>
     746:	50 91 e9 00 	lds	r21, 0x00E9	; 0x8000e9 <Time1_OVF_g+0x3>
     74a:	af ef       	ldi	r26, 0xFF	; 255
     74c:	bf ef       	ldi	r27, 0xFF	; 255
     74e:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <__muluhisi3>
     752:	dc 01       	movw	r26, r24
     754:	cb 01       	movw	r24, r22
     756:	8e 0f       	add	r24, r30
     758:	9f 1f       	adc	r25, r31
     75a:	a1 1d       	adc	r26, r1
     75c:	b1 1d       	adc	r27, r1
     75e:	80 93 b6 00 	sts	0x00B6, r24	; 0x8000b6 <CAP2>
     762:	90 93 b7 00 	sts	0x00B7, r25	; 0x8000b7 <CAP2+0x1>
     766:	a0 93 b8 00 	sts	0x00B8, r26	; 0x8000b8 <CAP2+0x2>
     76a:	b0 93 b9 00 	sts	0x00B9, r27	; 0x8000b9 <CAP2+0x3>
		/********* Rising eadge ******/
		SET_BIT(TCCR1B, 6);
     76e:	8e b5       	in	r24, 0x2e	; 46
     770:	80 64       	ori	r24, 0x40	; 64
     772:	8e bd       	out	0x2e, r24	; 46
     774:	23 c0       	rjmp	.+70     	; 0x7bc <__vector_6+0x112>
		
	}
	else if (ICU_Cnt ==	3)
     776:	03 97       	sbiw	r24, 0x03	; 3
     778:	a1 05       	cpc	r26, r1
     77a:	b1 05       	cpc	r27, r1
     77c:	f9 f4       	brne	.+62     	; 0x7bc <__vector_6+0x112>
	{
		Cap3 = ICR1_16Bit_Access + (Time1_OVF_g * 65535);
     77e:	e6 b5       	in	r30, 0x26	; 38
     780:	f7 b5       	in	r31, 0x27	; 39
     782:	20 91 e6 00 	lds	r18, 0x00E6	; 0x8000e6 <Time1_OVF_g>
     786:	30 91 e7 00 	lds	r19, 0x00E7	; 0x8000e7 <Time1_OVF_g+0x1>
     78a:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <Time1_OVF_g+0x2>
     78e:	50 91 e9 00 	lds	r21, 0x00E9	; 0x8000e9 <Time1_OVF_g+0x3>
     792:	af ef       	ldi	r26, 0xFF	; 255
     794:	bf ef       	ldi	r27, 0xFF	; 255
     796:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <__muluhisi3>
     79a:	dc 01       	movw	r26, r24
     79c:	cb 01       	movw	r24, r22
     79e:	8e 0f       	add	r24, r30
     7a0:	9f 1f       	adc	r25, r31
     7a2:	a1 1d       	adc	r26, r1
     7a4:	b1 1d       	adc	r27, r1
     7a6:	80 93 ae 00 	sts	0x00AE, r24	; 0x8000ae <Cap3>
     7aa:	90 93 af 00 	sts	0x00AF, r25	; 0x8000af <Cap3+0x1>
     7ae:	a0 93 b0 00 	sts	0x00B0, r26	; 0x8000b0 <Cap3+0x2>
     7b2:	b0 93 b1 00 	sts	0x00B1, r27	; 0x8000b1 <Cap3+0x3>
		
		/******** INT OFF ICU ***********/
		CLR_BIT(TIMSK,5);
     7b6:	89 b7       	in	r24, 0x39	; 57
     7b8:	8f 7d       	andi	r24, 0xDF	; 223
     7ba:	89 bf       	out	0x39, r24	; 57
	}
	
}
     7bc:	ff 91       	pop	r31
     7be:	ef 91       	pop	r30
     7c0:	bf 91       	pop	r27
     7c2:	af 91       	pop	r26
     7c4:	9f 91       	pop	r25
     7c6:	8f 91       	pop	r24
     7c8:	7f 91       	pop	r23
     7ca:	6f 91       	pop	r22
     7cc:	5f 91       	pop	r21
     7ce:	4f 91       	pop	r20
     7d0:	3f 91       	pop	r19
     7d2:	2f 91       	pop	r18
     7d4:	0f 90       	pop	r0
     7d6:	0f be       	out	0x3f, r0	; 63
     7d8:	0f 90       	pop	r0
     7da:	1f 90       	pop	r1
     7dc:	18 95       	reti

000007de <__vector_13>:


/************ UART ************/
ISR(USART_RXC_vect)
{
     7de:	1f 92       	push	r1
     7e0:	0f 92       	push	r0
     7e2:	0f b6       	in	r0, 0x3f	; 63
     7e4:	0f 92       	push	r0
     7e6:	11 24       	eor	r1, r1
     7e8:	2f 93       	push	r18
     7ea:	3f 93       	push	r19
     7ec:	4f 93       	push	r20
     7ee:	5f 93       	push	r21
     7f0:	6f 93       	push	r22
     7f2:	7f 93       	push	r23
     7f4:	8f 93       	push	r24
     7f6:	9f 93       	push	r25
     7f8:	af 93       	push	r26
     7fa:	bf 93       	push	r27
     7fc:	ef 93       	push	r30
     7fe:	ff 93       	push	r31
	if(CallBack_PtrFunc[USART_Rx_Complete_VECTOR_INDEX] != Null)
     800:	e0 91 d6 00 	lds	r30, 0x00D6	; 0x8000d6 <CallBack_PtrFunc+0x18>
     804:	f0 91 d7 00 	lds	r31, 0x00D7	; 0x8000d7 <CallBack_PtrFunc+0x19>
     808:	30 97       	sbiw	r30, 0x00	; 0
     80a:	09 f0       	breq	.+2      	; 0x80e <__DATA_REGION_LENGTH__+0xe>
	{
		(*CallBack_PtrFunc[USART_Rx_Complete_VECTOR_INDEX])();
     80c:	09 95       	icall
	}
}
     80e:	ff 91       	pop	r31
     810:	ef 91       	pop	r30
     812:	bf 91       	pop	r27
     814:	af 91       	pop	r26
     816:	9f 91       	pop	r25
     818:	8f 91       	pop	r24
     81a:	7f 91       	pop	r23
     81c:	6f 91       	pop	r22
     81e:	5f 91       	pop	r21
     820:	4f 91       	pop	r20
     822:	3f 91       	pop	r19
     824:	2f 91       	pop	r18
     826:	0f 90       	pop	r0
     828:	0f be       	out	0x3f, r0	; 63
     82a:	0f 90       	pop	r0
     82c:	1f 90       	pop	r1
     82e:	18 95       	reti

00000830 <__vector_15>:

ISR(USART_TXC_vect)
{
     830:	1f 92       	push	r1
     832:	0f 92       	push	r0
     834:	0f b6       	in	r0, 0x3f	; 63
     836:	0f 92       	push	r0
     838:	11 24       	eor	r1, r1
     83a:	8f 93       	push	r24
	
	TX_STATUS_FLAG =1;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <TX_STATUS_FLAG>
	TX_CNT++;
     842:	80 91 ea 00 	lds	r24, 0x00EA	; 0x8000ea <TX_CNT>
     846:	8f 5f       	subi	r24, 0xFF	; 255
     848:	80 93 ea 00 	sts	0x00EA, r24	; 0x8000ea <TX_CNT>
}
     84c:	8f 91       	pop	r24
     84e:	0f 90       	pop	r0
     850:	0f be       	out	0x3f, r0	; 63
     852:	0f 90       	pop	r0
     854:	1f 90       	pop	r1
     856:	18 95       	reti

00000858 <PORT_Init>:
*******************************************************************************/
void PORT_Init(void)
{
	uint8 Cnt = 0 , Port = 0 , Pin = 0 , Dir = 0 ;
	
	for(Cnt = 0 ; Cnt < DEFINED_PINS ; Cnt++)
     858:	90 e0       	ldi	r25, 0x00	; 0
     85a:	7e c0       	rjmp	.+252    	; 0x958 <__stack+0xf9>
	{
		Port = PORT_Initialization[Cnt].PIN_NUM / NUMBER_OF_EACH_PORT_PINS ;
     85c:	e9 2f       	mov	r30, r25
     85e:	f0 e0       	ldi	r31, 0x00	; 0
     860:	ee 0f       	add	r30, r30
     862:	ff 1f       	adc	r31, r31
     864:	e4 59       	subi	r30, 0x94	; 148
     866:	ff 4f       	sbci	r31, 0xFF	; 255
     868:	80 81       	ld	r24, Z
     86a:	28 2f       	mov	r18, r24
     86c:	26 95       	lsr	r18
     86e:	26 95       	lsr	r18
     870:	26 95       	lsr	r18
		Pin = PORT_Initialization[Cnt].PIN_NUM % NUMBER_OF_EACH_PORT_PINS  ;
     872:	87 70       	andi	r24, 0x07	; 7
		Dir = PORT_Initialization[Cnt].PIN_DIR ;
     874:	31 81       	ldd	r19, Z+1	; 0x01
		
		switch(Dir)
     876:	33 23       	and	r19, r19
     878:	b9 f1       	breq	.+110    	; 0x8e8 <__stack+0x89>
     87a:	31 30       	cpi	r19, 0x01	; 1
     87c:	09 f0       	breq	.+2      	; 0x880 <__stack+0x21>
     87e:	6b c0       	rjmp	.+214    	; 0x956 <__stack+0xf7>
		{
			case PIN_OUTPUT :
			
			switch(Port)
     880:	21 30       	cpi	r18, 0x01	; 1
     882:	89 f0       	breq	.+34     	; 0x8a6 <__stack+0x47>
     884:	28 f0       	brcs	.+10     	; 0x890 <__stack+0x31>
     886:	22 30       	cpi	r18, 0x02	; 2
     888:	c9 f0       	breq	.+50     	; 0x8bc <__stack+0x5d>
     88a:	23 30       	cpi	r18, 0x03	; 3
     88c:	11 f1       	breq	.+68     	; 0x8d2 <__stack+0x73>
     88e:	63 c0       	rjmp	.+198    	; 0x956 <__stack+0xf7>
			{
				case 0:
				SET_BIT(PHYSICAL_GPIO_ACCESS(GPIOA_BASE_ADDRRESS + GPIO_DIRCETION_REGISTER_DDR) ,Pin );
     890:	4a b3       	in	r20, 0x1a	; 26
     892:	21 e0       	ldi	r18, 0x01	; 1
     894:	30 e0       	ldi	r19, 0x00	; 0
     896:	02 c0       	rjmp	.+4      	; 0x89c <__stack+0x3d>
     898:	22 0f       	add	r18, r18
     89a:	33 1f       	adc	r19, r19
     89c:	8a 95       	dec	r24
     89e:	e2 f7       	brpl	.-8      	; 0x898 <__stack+0x39>
     8a0:	24 2b       	or	r18, r20
     8a2:	2a bb       	out	0x1a, r18	; 26

				break;
     8a4:	58 c0       	rjmp	.+176    	; 0x956 <__stack+0xf7>
				
				case 1:
				SET_BIT(PHYSICAL_GPIO_ACCESS(GPIOB_BASE_ADDRRESS + GPIO_DIRCETION_REGISTER_DDR) ,Pin );
     8a6:	47 b3       	in	r20, 0x17	; 23
     8a8:	21 e0       	ldi	r18, 0x01	; 1
     8aa:	30 e0       	ldi	r19, 0x00	; 0
     8ac:	02 c0       	rjmp	.+4      	; 0x8b2 <__stack+0x53>
     8ae:	22 0f       	add	r18, r18
     8b0:	33 1f       	adc	r19, r19
     8b2:	8a 95       	dec	r24
     8b4:	e2 f7       	brpl	.-8      	; 0x8ae <__stack+0x4f>
     8b6:	24 2b       	or	r18, r20
     8b8:	27 bb       	out	0x17, r18	; 23
				
				break;
     8ba:	4d c0       	rjmp	.+154    	; 0x956 <__stack+0xf7>
				
				case 2:
				SET_BIT(PHYSICAL_GPIO_ACCESS(GPIOC_BASE_ADDRRESS + GPIO_DIRCETION_REGISTER_DDR) ,Pin );
     8bc:	44 b3       	in	r20, 0x14	; 20
     8be:	21 e0       	ldi	r18, 0x01	; 1
     8c0:	30 e0       	ldi	r19, 0x00	; 0
     8c2:	02 c0       	rjmp	.+4      	; 0x8c8 <__stack+0x69>
     8c4:	22 0f       	add	r18, r18
     8c6:	33 1f       	adc	r19, r19
     8c8:	8a 95       	dec	r24
     8ca:	e2 f7       	brpl	.-8      	; 0x8c4 <__stack+0x65>
     8cc:	24 2b       	or	r18, r20
     8ce:	24 bb       	out	0x14, r18	; 20
				
				break;
     8d0:	42 c0       	rjmp	.+132    	; 0x956 <__stack+0xf7>
				
				case 3:
				SET_BIT(PHYSICAL_GPIO_ACCESS(GPIOD_BASE_ADDRRESS + GPIO_DIRCETION_REGISTER_DDR) ,Pin );
     8d2:	41 b3       	in	r20, 0x11	; 17
     8d4:	21 e0       	ldi	r18, 0x01	; 1
     8d6:	30 e0       	ldi	r19, 0x00	; 0
     8d8:	02 c0       	rjmp	.+4      	; 0x8de <__stack+0x7f>
     8da:	22 0f       	add	r18, r18
     8dc:	33 1f       	adc	r19, r19
     8de:	8a 95       	dec	r24
     8e0:	e2 f7       	brpl	.-8      	; 0x8da <__stack+0x7b>
     8e2:	24 2b       	or	r18, r20
     8e4:	21 bb       	out	0x11, r18	; 17
				
				break;
     8e6:	37 c0       	rjmp	.+110    	; 0x956 <__stack+0xf7>
				break;
			}
			break;
			
			case PIN_INPUT :
			switch(Port)
     8e8:	21 30       	cpi	r18, 0x01	; 1
     8ea:	91 f0       	breq	.+36     	; 0x910 <__stack+0xb1>
     8ec:	28 f0       	brcs	.+10     	; 0x8f8 <__stack+0x99>
     8ee:	22 30       	cpi	r18, 0x02	; 2
     8f0:	d9 f0       	breq	.+54     	; 0x928 <__stack+0xc9>
     8f2:	23 30       	cpi	r18, 0x03	; 3
     8f4:	29 f1       	breq	.+74     	; 0x940 <__stack+0xe1>
     8f6:	2f c0       	rjmp	.+94     	; 0x956 <__stack+0xf7>
			{
				case 0:
				CLR_BIT(PHYSICAL_GPIO_ACCESS(GPIOA_BASE_ADDRRESS + GPIO_DIRCETION_REGISTER_DDR) ,Pin );
     8f8:	4a b3       	in	r20, 0x1a	; 26
     8fa:	21 e0       	ldi	r18, 0x01	; 1
     8fc:	30 e0       	ldi	r19, 0x00	; 0
     8fe:	02 c0       	rjmp	.+4      	; 0x904 <__stack+0xa5>
     900:	22 0f       	add	r18, r18
     902:	33 1f       	adc	r19, r19
     904:	8a 95       	dec	r24
     906:	e2 f7       	brpl	.-8      	; 0x900 <__stack+0xa1>
     908:	20 95       	com	r18
     90a:	24 23       	and	r18, r20
     90c:	2a bb       	out	0x1a, r18	; 26

				break;
     90e:	23 c0       	rjmp	.+70     	; 0x956 <__stack+0xf7>
				
				case 1:
				CLR_BIT(PHYSICAL_GPIO_ACCESS(GPIOB_BASE_ADDRRESS + GPIO_DIRCETION_REGISTER_DDR) ,Pin );
     910:	47 b3       	in	r20, 0x17	; 23
     912:	21 e0       	ldi	r18, 0x01	; 1
     914:	30 e0       	ldi	r19, 0x00	; 0
     916:	02 c0       	rjmp	.+4      	; 0x91c <__stack+0xbd>
     918:	22 0f       	add	r18, r18
     91a:	33 1f       	adc	r19, r19
     91c:	8a 95       	dec	r24
     91e:	e2 f7       	brpl	.-8      	; 0x918 <__stack+0xb9>
     920:	20 95       	com	r18
     922:	24 23       	and	r18, r20
     924:	27 bb       	out	0x17, r18	; 23
				
				break;
     926:	17 c0       	rjmp	.+46     	; 0x956 <__stack+0xf7>
				
				case 2:
				CLR_BIT(PHYSICAL_GPIO_ACCESS(GPIOC_BASE_ADDRRESS + GPIO_DIRCETION_REGISTER_DDR) ,Pin );
     928:	44 b3       	in	r20, 0x14	; 20
     92a:	21 e0       	ldi	r18, 0x01	; 1
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	02 c0       	rjmp	.+4      	; 0x934 <__stack+0xd5>
     930:	22 0f       	add	r18, r18
     932:	33 1f       	adc	r19, r19
     934:	8a 95       	dec	r24
     936:	e2 f7       	brpl	.-8      	; 0x930 <__stack+0xd1>
     938:	20 95       	com	r18
     93a:	24 23       	and	r18, r20
     93c:	24 bb       	out	0x14, r18	; 20
				
				break;
     93e:	0b c0       	rjmp	.+22     	; 0x956 <__stack+0xf7>
				
				case 3:
				CLR_BIT(PHYSICAL_GPIO_ACCESS(GPIOD_BASE_ADDRRESS + GPIO_DIRCETION_REGISTER_DDR) ,Pin );
     940:	41 b3       	in	r20, 0x11	; 17
     942:	21 e0       	ldi	r18, 0x01	; 1
     944:	30 e0       	ldi	r19, 0x00	; 0
     946:	02 c0       	rjmp	.+4      	; 0x94c <__stack+0xed>
     948:	22 0f       	add	r18, r18
     94a:	33 1f       	adc	r19, r19
     94c:	8a 95       	dec	r24
     94e:	e2 f7       	brpl	.-8      	; 0x948 <__stack+0xe9>
     950:	20 95       	com	r18
     952:	24 23       	and	r18, r20
     954:	21 bb       	out	0x11, r18	; 17
*******************************************************************************/
void PORT_Init(void)
{
	uint8 Cnt = 0 , Port = 0 , Pin = 0 , Dir = 0 ;
	
	for(Cnt = 0 ; Cnt < DEFINED_PINS ; Cnt++)
     956:	9f 5f       	subi	r25, 0xFF	; 255
     958:	9e 30       	cpi	r25, 0x0E	; 14
     95a:	08 f4       	brcc	.+2      	; 0x95e <__stack+0xff>
     95c:	7f cf       	rjmp	.-258    	; 0x85c <PORT_Init+0x4>
			
			default:
			break;
		}
	}
}
     95e:	08 95       	ret

00000960 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     960:	cf 93       	push	r28
     962:	df 93       	push	r29
     964:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     966:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     96a:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <pucAlignedHeap.2084>
     96e:	90 91 ed 00 	lds	r25, 0x00ED	; 0x8000ed <pucAlignedHeap.2084+0x1>
     972:	89 2b       	or	r24, r25
     974:	31 f4       	brne	.+12     	; 0x982 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     976:	81 ef       	ldi	r24, 0xF1	; 241
     978:	90 e0       	ldi	r25, 0x00	; 0
     97a:	90 93 ed 00 	sts	0x00ED, r25	; 0x8000ed <pucAlignedHeap.2084+0x1>
     97e:	80 93 ec 00 	sts	0x00EC, r24	; 0x8000ec <pucAlignedHeap.2084>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     982:	20 91 ee 00 	lds	r18, 0x00EE	; 0x8000ee <xNextFreeByte>
     986:	30 91 ef 00 	lds	r19, 0x00EF	; 0x8000ef <xNextFreeByte+0x1>
     98a:	c9 01       	movw	r24, r18
     98c:	8c 0f       	add	r24, r28
     98e:	9d 1f       	adc	r25, r29
     990:	8b 3d       	cpi	r24, 0xDB	; 219
     992:	45 e0       	ldi	r20, 0x05	; 5
     994:	94 07       	cpc	r25, r20
     996:	70 f4       	brcc	.+28     	; 0x9b4 <pvPortMalloc+0x54>
     998:	28 17       	cp	r18, r24
     99a:	39 07       	cpc	r19, r25
     99c:	70 f4       	brcc	.+28     	; 0x9ba <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     99e:	c0 91 ec 00 	lds	r28, 0x00EC	; 0x8000ec <pucAlignedHeap.2084>
     9a2:	d0 91 ed 00 	lds	r29, 0x00ED	; 0x8000ed <pucAlignedHeap.2084+0x1>
     9a6:	c2 0f       	add	r28, r18
     9a8:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     9aa:	90 93 ef 00 	sts	0x00EF, r25	; 0x8000ef <xNextFreeByte+0x1>
     9ae:	80 93 ee 00 	sts	0x00EE, r24	; 0x8000ee <xNextFreeByte>
     9b2:	05 c0       	rjmp	.+10     	; 0x9be <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     9b4:	c0 e0       	ldi	r28, 0x00	; 0
     9b6:	d0 e0       	ldi	r29, 0x00	; 0
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <pvPortMalloc+0x5e>
     9ba:	c0 e0       	ldi	r28, 0x00	; 0
     9bc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     9be:	0e 94 12 0c 	call	0x1824	; 0x1824 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     9c2:	ce 01       	movw	r24, r28
     9c4:	df 91       	pop	r29
     9c6:	cf 91       	pop	r28
     9c8:	08 95       	ret

000009ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     9ca:	08 95       	ret

000009cc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     9cc:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9ce:	03 96       	adiw	r24, 0x03	; 3
     9d0:	92 83       	std	Z+2, r25	; 0x02
     9d2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     9d4:	2f ef       	ldi	r18, 0xFF	; 255
     9d6:	3f ef       	ldi	r19, 0xFF	; 255
     9d8:	34 83       	std	Z+4, r19	; 0x04
     9da:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9dc:	96 83       	std	Z+6, r25	; 0x06
     9de:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9e0:	90 87       	std	Z+8, r25	; 0x08
     9e2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     9e4:	10 82       	st	Z, r1
     9e6:	08 95       	ret

000009e8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     9e8:	fc 01       	movw	r30, r24
     9ea:	11 86       	std	Z+9, r1	; 0x09
     9ec:	10 86       	std	Z+8, r1	; 0x08
     9ee:	08 95       	ret

000009f0 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9f0:	cf 93       	push	r28
     9f2:	df 93       	push	r29
     9f4:	9c 01       	movw	r18, r24
     9f6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9f8:	dc 01       	movw	r26, r24
     9fa:	11 96       	adiw	r26, 0x01	; 1
     9fc:	cd 91       	ld	r28, X+
     9fe:	dc 91       	ld	r29, X
     a00:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     a02:	d3 83       	std	Z+3, r29	; 0x03
     a04:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     a06:	8c 81       	ldd	r24, Y+4	; 0x04
     a08:	9d 81       	ldd	r25, Y+5	; 0x05
     a0a:	95 83       	std	Z+5, r25	; 0x05
     a0c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     a0e:	8c 81       	ldd	r24, Y+4	; 0x04
     a10:	9d 81       	ldd	r25, Y+5	; 0x05
     a12:	dc 01       	movw	r26, r24
     a14:	13 96       	adiw	r26, 0x03	; 3
     a16:	7c 93       	st	X, r23
     a18:	6e 93       	st	-X, r22
     a1a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     a1c:	7d 83       	std	Y+5, r23	; 0x05
     a1e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     a20:	31 87       	std	Z+9, r19	; 0x09
     a22:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     a24:	f9 01       	movw	r30, r18
     a26:	80 81       	ld	r24, Z
     a28:	8f 5f       	subi	r24, 0xFF	; 255
     a2a:	80 83       	st	Z, r24
}
     a2c:	df 91       	pop	r29
     a2e:	cf 91       	pop	r28
     a30:	08 95       	ret

00000a32 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     a38:	48 81       	ld	r20, Y
     a3a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     a3c:	4f 3f       	cpi	r20, 0xFF	; 255
     a3e:	2f ef       	ldi	r18, 0xFF	; 255
     a40:	52 07       	cpc	r21, r18
     a42:	21 f4       	brne	.+8      	; 0xa4c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     a44:	fc 01       	movw	r30, r24
     a46:	a7 81       	ldd	r26, Z+7	; 0x07
     a48:	b0 85       	ldd	r27, Z+8	; 0x08
     a4a:	0d c0       	rjmp	.+26     	; 0xa66 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     a4c:	dc 01       	movw	r26, r24
     a4e:	13 96       	adiw	r26, 0x03	; 3
     a50:	01 c0       	rjmp	.+2      	; 0xa54 <vListInsert+0x22>
     a52:	df 01       	movw	r26, r30
     a54:	12 96       	adiw	r26, 0x02	; 2
     a56:	ed 91       	ld	r30, X+
     a58:	fc 91       	ld	r31, X
     a5a:	13 97       	sbiw	r26, 0x03	; 3
     a5c:	20 81       	ld	r18, Z
     a5e:	31 81       	ldd	r19, Z+1	; 0x01
     a60:	42 17       	cp	r20, r18
     a62:	53 07       	cpc	r21, r19
     a64:	b0 f7       	brcc	.-20     	; 0xa52 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a66:	12 96       	adiw	r26, 0x02	; 2
     a68:	ed 91       	ld	r30, X+
     a6a:	fc 91       	ld	r31, X
     a6c:	13 97       	sbiw	r26, 0x03	; 3
     a6e:	fb 83       	std	Y+3, r31	; 0x03
     a70:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a72:	d5 83       	std	Z+5, r29	; 0x05
     a74:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a76:	bd 83       	std	Y+5, r27	; 0x05
     a78:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a7a:	13 96       	adiw	r26, 0x03	; 3
     a7c:	dc 93       	st	X, r29
     a7e:	ce 93       	st	-X, r28
     a80:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     a82:	99 87       	std	Y+9, r25	; 0x09
     a84:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a86:	fc 01       	movw	r30, r24
     a88:	20 81       	ld	r18, Z
     a8a:	2f 5f       	subi	r18, 0xFF	; 255
     a8c:	20 83       	st	Z, r18
}
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	08 95       	ret

00000a94 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     a9a:	a0 85       	ldd	r26, Z+8	; 0x08
     a9c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a9e:	c2 81       	ldd	r28, Z+2	; 0x02
     aa0:	d3 81       	ldd	r29, Z+3	; 0x03
     aa2:	84 81       	ldd	r24, Z+4	; 0x04
     aa4:	95 81       	ldd	r25, Z+5	; 0x05
     aa6:	9d 83       	std	Y+5, r25	; 0x05
     aa8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     aaa:	c4 81       	ldd	r28, Z+4	; 0x04
     aac:	d5 81       	ldd	r29, Z+5	; 0x05
     aae:	82 81       	ldd	r24, Z+2	; 0x02
     ab0:	93 81       	ldd	r25, Z+3	; 0x03
     ab2:	9b 83       	std	Y+3, r25	; 0x03
     ab4:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ab6:	11 96       	adiw	r26, 0x01	; 1
     ab8:	8d 91       	ld	r24, X+
     aba:	9c 91       	ld	r25, X
     abc:	12 97       	sbiw	r26, 0x02	; 2
     abe:	e8 17       	cp	r30, r24
     ac0:	f9 07       	cpc	r31, r25
     ac2:	31 f4       	brne	.+12     	; 0xad0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ac4:	84 81       	ldd	r24, Z+4	; 0x04
     ac6:	95 81       	ldd	r25, Z+5	; 0x05
     ac8:	12 96       	adiw	r26, 0x02	; 2
     aca:	9c 93       	st	X, r25
     acc:	8e 93       	st	-X, r24
     ace:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     ad0:	11 86       	std	Z+9, r1	; 0x09
     ad2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     ad4:	8c 91       	ld	r24, X
     ad6:	81 50       	subi	r24, 0x01	; 1
     ad8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     ada:	8c 91       	ld	r24, X
}
     adc:	df 91       	pop	r29
     ade:	cf 91       	pop	r28
     ae0:	08 95       	ret

00000ae2 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     ae2:	1b bc       	out	0x2b, r1	; 43
     ae4:	8c e7       	ldi	r24, 0x7C	; 124
     ae6:	8a bd       	out	0x2a, r24	; 42
     ae8:	8b e0       	ldi	r24, 0x0B	; 11
     aea:	8e bd       	out	0x2e, r24	; 46
     aec:	89 b7       	in	r24, 0x39	; 57
     aee:	80 61       	ori	r24, 0x10	; 16
     af0:	89 bf       	out	0x39, r24	; 57
     af2:	08 95       	ret

00000af4 <pxPortInitialiseStack>:
     af4:	31 e1       	ldi	r19, 0x11	; 17
     af6:	fc 01       	movw	r30, r24
     af8:	30 83       	st	Z, r19
     afa:	31 97       	sbiw	r30, 0x01	; 1
     afc:	22 e2       	ldi	r18, 0x22	; 34
     afe:	20 83       	st	Z, r18
     b00:	31 97       	sbiw	r30, 0x01	; 1
     b02:	a3 e3       	ldi	r26, 0x33	; 51
     b04:	a0 83       	st	Z, r26
     b06:	31 97       	sbiw	r30, 0x01	; 1
     b08:	60 83       	st	Z, r22
     b0a:	31 97       	sbiw	r30, 0x01	; 1
     b0c:	70 83       	st	Z, r23
     b0e:	31 97       	sbiw	r30, 0x01	; 1
     b10:	10 82       	st	Z, r1
     b12:	31 97       	sbiw	r30, 0x01	; 1
     b14:	60 e8       	ldi	r22, 0x80	; 128
     b16:	60 83       	st	Z, r22
     b18:	31 97       	sbiw	r30, 0x01	; 1
     b1a:	10 82       	st	Z, r1
     b1c:	31 97       	sbiw	r30, 0x01	; 1
     b1e:	62 e0       	ldi	r22, 0x02	; 2
     b20:	60 83       	st	Z, r22
     b22:	31 97       	sbiw	r30, 0x01	; 1
     b24:	63 e0       	ldi	r22, 0x03	; 3
     b26:	60 83       	st	Z, r22
     b28:	31 97       	sbiw	r30, 0x01	; 1
     b2a:	64 e0       	ldi	r22, 0x04	; 4
     b2c:	60 83       	st	Z, r22
     b2e:	31 97       	sbiw	r30, 0x01	; 1
     b30:	65 e0       	ldi	r22, 0x05	; 5
     b32:	60 83       	st	Z, r22
     b34:	31 97       	sbiw	r30, 0x01	; 1
     b36:	66 e0       	ldi	r22, 0x06	; 6
     b38:	60 83       	st	Z, r22
     b3a:	31 97       	sbiw	r30, 0x01	; 1
     b3c:	67 e0       	ldi	r22, 0x07	; 7
     b3e:	60 83       	st	Z, r22
     b40:	31 97       	sbiw	r30, 0x01	; 1
     b42:	68 e0       	ldi	r22, 0x08	; 8
     b44:	60 83       	st	Z, r22
     b46:	31 97       	sbiw	r30, 0x01	; 1
     b48:	69 e0       	ldi	r22, 0x09	; 9
     b4a:	60 83       	st	Z, r22
     b4c:	31 97       	sbiw	r30, 0x01	; 1
     b4e:	60 e1       	ldi	r22, 0x10	; 16
     b50:	60 83       	st	Z, r22
     b52:	31 97       	sbiw	r30, 0x01	; 1
     b54:	30 83       	st	Z, r19
     b56:	31 97       	sbiw	r30, 0x01	; 1
     b58:	32 e1       	ldi	r19, 0x12	; 18
     b5a:	30 83       	st	Z, r19
     b5c:	31 97       	sbiw	r30, 0x01	; 1
     b5e:	33 e1       	ldi	r19, 0x13	; 19
     b60:	30 83       	st	Z, r19
     b62:	31 97       	sbiw	r30, 0x01	; 1
     b64:	34 e1       	ldi	r19, 0x14	; 20
     b66:	30 83       	st	Z, r19
     b68:	31 97       	sbiw	r30, 0x01	; 1
     b6a:	35 e1       	ldi	r19, 0x15	; 21
     b6c:	30 83       	st	Z, r19
     b6e:	31 97       	sbiw	r30, 0x01	; 1
     b70:	36 e1       	ldi	r19, 0x16	; 22
     b72:	30 83       	st	Z, r19
     b74:	31 97       	sbiw	r30, 0x01	; 1
     b76:	37 e1       	ldi	r19, 0x17	; 23
     b78:	30 83       	st	Z, r19
     b7a:	31 97       	sbiw	r30, 0x01	; 1
     b7c:	38 e1       	ldi	r19, 0x18	; 24
     b7e:	30 83       	st	Z, r19
     b80:	31 97       	sbiw	r30, 0x01	; 1
     b82:	39 e1       	ldi	r19, 0x19	; 25
     b84:	30 83       	st	Z, r19
     b86:	31 97       	sbiw	r30, 0x01	; 1
     b88:	30 e2       	ldi	r19, 0x20	; 32
     b8a:	30 83       	st	Z, r19
     b8c:	31 97       	sbiw	r30, 0x01	; 1
     b8e:	31 e2       	ldi	r19, 0x21	; 33
     b90:	30 83       	st	Z, r19
     b92:	31 97       	sbiw	r30, 0x01	; 1
     b94:	20 83       	st	Z, r18
     b96:	31 97       	sbiw	r30, 0x01	; 1
     b98:	23 e2       	ldi	r18, 0x23	; 35
     b9a:	20 83       	st	Z, r18
     b9c:	31 97       	sbiw	r30, 0x01	; 1
     b9e:	40 83       	st	Z, r20
     ba0:	31 97       	sbiw	r30, 0x01	; 1
     ba2:	50 83       	st	Z, r21
     ba4:	31 97       	sbiw	r30, 0x01	; 1
     ba6:	26 e2       	ldi	r18, 0x26	; 38
     ba8:	20 83       	st	Z, r18
     baa:	31 97       	sbiw	r30, 0x01	; 1
     bac:	27 e2       	ldi	r18, 0x27	; 39
     bae:	20 83       	st	Z, r18
     bb0:	31 97       	sbiw	r30, 0x01	; 1
     bb2:	28 e2       	ldi	r18, 0x28	; 40
     bb4:	20 83       	st	Z, r18
     bb6:	31 97       	sbiw	r30, 0x01	; 1
     bb8:	29 e2       	ldi	r18, 0x29	; 41
     bba:	20 83       	st	Z, r18
     bbc:	31 97       	sbiw	r30, 0x01	; 1
     bbe:	20 e3       	ldi	r18, 0x30	; 48
     bc0:	20 83       	st	Z, r18
     bc2:	31 97       	sbiw	r30, 0x01	; 1
     bc4:	21 e3       	ldi	r18, 0x31	; 49
     bc6:	20 83       	st	Z, r18
     bc8:	86 97       	sbiw	r24, 0x26	; 38
     bca:	08 95       	ret

00000bcc <xPortStartScheduler>:
     bcc:	0e 94 71 05 	call	0xae2	; 0xae2 <prvSetupTimerInterrupt>
     bd0:	a0 91 30 07 	lds	r26, 0x0730	; 0x800730 <pxCurrentTCB>
     bd4:	b0 91 31 07 	lds	r27, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
     bd8:	cd 91       	ld	r28, X+
     bda:	cd bf       	out	0x3d, r28	; 61
     bdc:	dd 91       	ld	r29, X+
     bde:	de bf       	out	0x3e, r29	; 62
     be0:	ff 91       	pop	r31
     be2:	ef 91       	pop	r30
     be4:	df 91       	pop	r29
     be6:	cf 91       	pop	r28
     be8:	bf 91       	pop	r27
     bea:	af 91       	pop	r26
     bec:	9f 91       	pop	r25
     bee:	8f 91       	pop	r24
     bf0:	7f 91       	pop	r23
     bf2:	6f 91       	pop	r22
     bf4:	5f 91       	pop	r21
     bf6:	4f 91       	pop	r20
     bf8:	3f 91       	pop	r19
     bfa:	2f 91       	pop	r18
     bfc:	1f 91       	pop	r17
     bfe:	0f 91       	pop	r16
     c00:	ff 90       	pop	r15
     c02:	ef 90       	pop	r14
     c04:	df 90       	pop	r13
     c06:	cf 90       	pop	r12
     c08:	bf 90       	pop	r11
     c0a:	af 90       	pop	r10
     c0c:	9f 90       	pop	r9
     c0e:	8f 90       	pop	r8
     c10:	7f 90       	pop	r7
     c12:	6f 90       	pop	r6
     c14:	5f 90       	pop	r5
     c16:	4f 90       	pop	r4
     c18:	3f 90       	pop	r3
     c1a:	2f 90       	pop	r2
     c1c:	1f 90       	pop	r1
     c1e:	0f 90       	pop	r0
     c20:	0f be       	out	0x3f, r0	; 63
     c22:	0f 90       	pop	r0
     c24:	08 95       	ret
     c26:	81 e0       	ldi	r24, 0x01	; 1
     c28:	08 95       	ret

00000c2a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     c2a:	0f 92       	push	r0
     c2c:	0f b6       	in	r0, 0x3f	; 63
     c2e:	f8 94       	cli
     c30:	0f 92       	push	r0
     c32:	1f 92       	push	r1
     c34:	11 24       	eor	r1, r1
     c36:	2f 92       	push	r2
     c38:	3f 92       	push	r3
     c3a:	4f 92       	push	r4
     c3c:	5f 92       	push	r5
     c3e:	6f 92       	push	r6
     c40:	7f 92       	push	r7
     c42:	8f 92       	push	r8
     c44:	9f 92       	push	r9
     c46:	af 92       	push	r10
     c48:	bf 92       	push	r11
     c4a:	cf 92       	push	r12
     c4c:	df 92       	push	r13
     c4e:	ef 92       	push	r14
     c50:	ff 92       	push	r15
     c52:	0f 93       	push	r16
     c54:	1f 93       	push	r17
     c56:	2f 93       	push	r18
     c58:	3f 93       	push	r19
     c5a:	4f 93       	push	r20
     c5c:	5f 93       	push	r21
     c5e:	6f 93       	push	r22
     c60:	7f 93       	push	r23
     c62:	8f 93       	push	r24
     c64:	9f 93       	push	r25
     c66:	af 93       	push	r26
     c68:	bf 93       	push	r27
     c6a:	cf 93       	push	r28
     c6c:	df 93       	push	r29
     c6e:	ef 93       	push	r30
     c70:	ff 93       	push	r31
     c72:	a0 91 30 07 	lds	r26, 0x0730	; 0x800730 <pxCurrentTCB>
     c76:	b0 91 31 07 	lds	r27, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
     c7a:	0d b6       	in	r0, 0x3d	; 61
     c7c:	0d 92       	st	X+, r0
     c7e:	0e b6       	in	r0, 0x3e	; 62
     c80:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c82:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c86:	a0 91 30 07 	lds	r26, 0x0730	; 0x800730 <pxCurrentTCB>
     c8a:	b0 91 31 07 	lds	r27, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
     c8e:	cd 91       	ld	r28, X+
     c90:	cd bf       	out	0x3d, r28	; 61
     c92:	dd 91       	ld	r29, X+
     c94:	de bf       	out	0x3e, r29	; 62
     c96:	ff 91       	pop	r31
     c98:	ef 91       	pop	r30
     c9a:	df 91       	pop	r29
     c9c:	cf 91       	pop	r28
     c9e:	bf 91       	pop	r27
     ca0:	af 91       	pop	r26
     ca2:	9f 91       	pop	r25
     ca4:	8f 91       	pop	r24
     ca6:	7f 91       	pop	r23
     ca8:	6f 91       	pop	r22
     caa:	5f 91       	pop	r21
     cac:	4f 91       	pop	r20
     cae:	3f 91       	pop	r19
     cb0:	2f 91       	pop	r18
     cb2:	1f 91       	pop	r17
     cb4:	0f 91       	pop	r16
     cb6:	ff 90       	pop	r15
     cb8:	ef 90       	pop	r14
     cba:	df 90       	pop	r13
     cbc:	cf 90       	pop	r12
     cbe:	bf 90       	pop	r11
     cc0:	af 90       	pop	r10
     cc2:	9f 90       	pop	r9
     cc4:	8f 90       	pop	r8
     cc6:	7f 90       	pop	r7
     cc8:	6f 90       	pop	r6
     cca:	5f 90       	pop	r5
     ccc:	4f 90       	pop	r4
     cce:	3f 90       	pop	r3
     cd0:	2f 90       	pop	r2
     cd2:	1f 90       	pop	r1
     cd4:	0f 90       	pop	r0
     cd6:	0f be       	out	0x3f, r0	; 63
     cd8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     cda:	08 95       	ret

00000cdc <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     cdc:	0f 92       	push	r0
     cde:	0f b6       	in	r0, 0x3f	; 63
     ce0:	f8 94       	cli
     ce2:	0f 92       	push	r0
     ce4:	1f 92       	push	r1
     ce6:	11 24       	eor	r1, r1
     ce8:	2f 92       	push	r2
     cea:	3f 92       	push	r3
     cec:	4f 92       	push	r4
     cee:	5f 92       	push	r5
     cf0:	6f 92       	push	r6
     cf2:	7f 92       	push	r7
     cf4:	8f 92       	push	r8
     cf6:	9f 92       	push	r9
     cf8:	af 92       	push	r10
     cfa:	bf 92       	push	r11
     cfc:	cf 92       	push	r12
     cfe:	df 92       	push	r13
     d00:	ef 92       	push	r14
     d02:	ff 92       	push	r15
     d04:	0f 93       	push	r16
     d06:	1f 93       	push	r17
     d08:	2f 93       	push	r18
     d0a:	3f 93       	push	r19
     d0c:	4f 93       	push	r20
     d0e:	5f 93       	push	r21
     d10:	6f 93       	push	r22
     d12:	7f 93       	push	r23
     d14:	8f 93       	push	r24
     d16:	9f 93       	push	r25
     d18:	af 93       	push	r26
     d1a:	bf 93       	push	r27
     d1c:	cf 93       	push	r28
     d1e:	df 93       	push	r29
     d20:	ef 93       	push	r30
     d22:	ff 93       	push	r31
     d24:	a0 91 30 07 	lds	r26, 0x0730	; 0x800730 <pxCurrentTCB>
     d28:	b0 91 31 07 	lds	r27, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
     d2c:	0d b6       	in	r0, 0x3d	; 61
     d2e:	0d 92       	st	X+, r0
     d30:	0e b6       	in	r0, 0x3e	; 62
     d32:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     d34:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <xTaskIncrementTick>
     d38:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     d3a:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     d3e:	a0 91 30 07 	lds	r26, 0x0730	; 0x800730 <pxCurrentTCB>
     d42:	b0 91 31 07 	lds	r27, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
     d46:	cd 91       	ld	r28, X+
     d48:	cd bf       	out	0x3d, r28	; 61
     d4a:	dd 91       	ld	r29, X+
     d4c:	de bf       	out	0x3e, r29	; 62
     d4e:	ff 91       	pop	r31
     d50:	ef 91       	pop	r30
     d52:	df 91       	pop	r29
     d54:	cf 91       	pop	r28
     d56:	bf 91       	pop	r27
     d58:	af 91       	pop	r26
     d5a:	9f 91       	pop	r25
     d5c:	8f 91       	pop	r24
     d5e:	7f 91       	pop	r23
     d60:	6f 91       	pop	r22
     d62:	5f 91       	pop	r21
     d64:	4f 91       	pop	r20
     d66:	3f 91       	pop	r19
     d68:	2f 91       	pop	r18
     d6a:	1f 91       	pop	r17
     d6c:	0f 91       	pop	r16
     d6e:	ff 90       	pop	r15
     d70:	ef 90       	pop	r14
     d72:	df 90       	pop	r13
     d74:	cf 90       	pop	r12
     d76:	bf 90       	pop	r11
     d78:	af 90       	pop	r10
     d7a:	9f 90       	pop	r9
     d7c:	8f 90       	pop	r8
     d7e:	7f 90       	pop	r7
     d80:	6f 90       	pop	r6
     d82:	5f 90       	pop	r5
     d84:	4f 90       	pop	r4
     d86:	3f 90       	pop	r3
     d88:	2f 90       	pop	r2
     d8a:	1f 90       	pop	r1
     d8c:	0f 90       	pop	r0
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d92:	08 95       	ret

00000d94 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     d94:	0e 94 6e 06 	call	0xcdc	; 0xcdc <vPortYieldFromTick>
		asm volatile ( "reti" );
     d98:	18 95       	reti

00000d9a <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     d9a:	0f b6       	in	r0, 0x3f	; 63
     d9c:	f8 94       	cli
     d9e:	0f 92       	push	r0
     da0:	fc 01       	movw	r30, r24
     da2:	82 8d       	ldd	r24, Z+26	; 0x1a
     da4:	81 11       	cpse	r24, r1
     da6:	02 c0       	rjmp	.+4      	; 0xdac <prvIsQueueEmpty+0x12>
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	01 c0       	rjmp	.+2      	; 0xdae <prvIsQueueEmpty+0x14>
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	0f 90       	pop	r0
     db0:	0f be       	out	0x3f, r0	; 63
     db2:	08 95       	ret

00000db4 <prvIsQueueFull>:
     db4:	0f b6       	in	r0, 0x3f	; 63
     db6:	f8 94       	cli
     db8:	0f 92       	push	r0
     dba:	fc 01       	movw	r30, r24
     dbc:	22 8d       	ldd	r18, Z+26	; 0x1a
     dbe:	83 8d       	ldd	r24, Z+27	; 0x1b
     dc0:	28 13       	cpse	r18, r24
     dc2:	02 c0       	rjmp	.+4      	; 0xdc8 <prvIsQueueFull+0x14>
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	01 c0       	rjmp	.+2      	; 0xdca <prvIsQueueFull+0x16>
     dc8:	80 e0       	ldi	r24, 0x00	; 0
     dca:	0f 90       	pop	r0
     dcc:	0f be       	out	0x3f, r0	; 63
     dce:	08 95       	ret

00000dd0 <prvCopyDataToQueue>:
     dd0:	0f 93       	push	r16
     dd2:	1f 93       	push	r17
     dd4:	cf 93       	push	r28
     dd6:	df 93       	push	r29
     dd8:	ec 01       	movw	r28, r24
     dda:	04 2f       	mov	r16, r20
     ddc:	1a 8d       	ldd	r17, Y+26	; 0x1a
     dde:	4c 8d       	ldd	r20, Y+28	; 0x1c
     de0:	44 23       	and	r20, r20
     de2:	b9 f1       	breq	.+110    	; 0xe52 <prvCopyDataToQueue+0x82>
     de4:	01 11       	cpse	r16, r1
     de6:	16 c0       	rjmp	.+44     	; 0xe14 <prvCopyDataToQueue+0x44>
     de8:	50 e0       	ldi	r21, 0x00	; 0
     dea:	8a 81       	ldd	r24, Y+2	; 0x02
     dec:	9b 81       	ldd	r25, Y+3	; 0x03
     dee:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <memcpy>
     df2:	2c 8d       	ldd	r18, Y+28	; 0x1c
     df4:	8a 81       	ldd	r24, Y+2	; 0x02
     df6:	9b 81       	ldd	r25, Y+3	; 0x03
     df8:	82 0f       	add	r24, r18
     dfa:	91 1d       	adc	r25, r1
     dfc:	9b 83       	std	Y+3, r25	; 0x03
     dfe:	8a 83       	std	Y+2, r24	; 0x02
     e00:	2c 81       	ldd	r18, Y+4	; 0x04
     e02:	3d 81       	ldd	r19, Y+5	; 0x05
     e04:	82 17       	cp	r24, r18
     e06:	93 07       	cpc	r25, r19
     e08:	20 f1       	brcs	.+72     	; 0xe52 <prvCopyDataToQueue+0x82>
     e0a:	88 81       	ld	r24, Y
     e0c:	99 81       	ldd	r25, Y+1	; 0x01
     e0e:	9b 83       	std	Y+3, r25	; 0x03
     e10:	8a 83       	std	Y+2, r24	; 0x02
     e12:	1f c0       	rjmp	.+62     	; 0xe52 <prvCopyDataToQueue+0x82>
     e14:	50 e0       	ldi	r21, 0x00	; 0
     e16:	8e 81       	ldd	r24, Y+6	; 0x06
     e18:	9f 81       	ldd	r25, Y+7	; 0x07
     e1a:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <memcpy>
     e1e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	91 95       	neg	r25
     e24:	81 95       	neg	r24
     e26:	91 09       	sbc	r25, r1
     e28:	2e 81       	ldd	r18, Y+6	; 0x06
     e2a:	3f 81       	ldd	r19, Y+7	; 0x07
     e2c:	28 0f       	add	r18, r24
     e2e:	39 1f       	adc	r19, r25
     e30:	3f 83       	std	Y+7, r19	; 0x07
     e32:	2e 83       	std	Y+6, r18	; 0x06
     e34:	48 81       	ld	r20, Y
     e36:	59 81       	ldd	r21, Y+1	; 0x01
     e38:	24 17       	cp	r18, r20
     e3a:	35 07       	cpc	r19, r21
     e3c:	30 f4       	brcc	.+12     	; 0xe4a <prvCopyDataToQueue+0x7a>
     e3e:	2c 81       	ldd	r18, Y+4	; 0x04
     e40:	3d 81       	ldd	r19, Y+5	; 0x05
     e42:	82 0f       	add	r24, r18
     e44:	93 1f       	adc	r25, r19
     e46:	9f 83       	std	Y+7, r25	; 0x07
     e48:	8e 83       	std	Y+6, r24	; 0x06
     e4a:	02 30       	cpi	r16, 0x02	; 2
     e4c:	11 f4       	brne	.+4      	; 0xe52 <prvCopyDataToQueue+0x82>
     e4e:	11 11       	cpse	r17, r1
     e50:	11 50       	subi	r17, 0x01	; 1
     e52:	1f 5f       	subi	r17, 0xFF	; 255
     e54:	1a 8f       	std	Y+26, r17	; 0x1a
     e56:	80 e0       	ldi	r24, 0x00	; 0
     e58:	df 91       	pop	r29
     e5a:	cf 91       	pop	r28
     e5c:	1f 91       	pop	r17
     e5e:	0f 91       	pop	r16
     e60:	08 95       	ret

00000e62 <prvCopyDataFromQueue>:
     e62:	fc 01       	movw	r30, r24
     e64:	44 8d       	ldd	r20, Z+28	; 0x1c
     e66:	44 23       	and	r20, r20
     e68:	a9 f0       	breq	.+42     	; 0xe94 <prvCopyDataFromQueue+0x32>
     e6a:	50 e0       	ldi	r21, 0x00	; 0
     e6c:	26 81       	ldd	r18, Z+6	; 0x06
     e6e:	37 81       	ldd	r19, Z+7	; 0x07
     e70:	24 0f       	add	r18, r20
     e72:	35 1f       	adc	r19, r21
     e74:	37 83       	std	Z+7, r19	; 0x07
     e76:	26 83       	std	Z+6, r18	; 0x06
     e78:	84 81       	ldd	r24, Z+4	; 0x04
     e7a:	95 81       	ldd	r25, Z+5	; 0x05
     e7c:	28 17       	cp	r18, r24
     e7e:	39 07       	cpc	r19, r25
     e80:	20 f0       	brcs	.+8      	; 0xe8a <prvCopyDataFromQueue+0x28>
     e82:	80 81       	ld	r24, Z
     e84:	91 81       	ldd	r25, Z+1	; 0x01
     e86:	97 83       	std	Z+7, r25	; 0x07
     e88:	86 83       	std	Z+6, r24	; 0x06
     e8a:	cb 01       	movw	r24, r22
     e8c:	66 81       	ldd	r22, Z+6	; 0x06
     e8e:	77 81       	ldd	r23, Z+7	; 0x07
     e90:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <memcpy>
     e94:	08 95       	ret

00000e96 <prvUnlockQueue>:
     e96:	1f 93       	push	r17
     e98:	cf 93       	push	r28
     e9a:	df 93       	push	r29
     e9c:	ec 01       	movw	r28, r24
     e9e:	0f b6       	in	r0, 0x3f	; 63
     ea0:	f8 94       	cli
     ea2:	0f 92       	push	r0
     ea4:	1e 8d       	ldd	r17, Y+30	; 0x1e
     ea6:	0b c0       	rjmp	.+22     	; 0xebe <prvUnlockQueue+0x28>
     ea8:	89 89       	ldd	r24, Y+17	; 0x11
     eaa:	88 23       	and	r24, r24
     eac:	51 f0       	breq	.+20     	; 0xec2 <prvUnlockQueue+0x2c>
     eae:	ce 01       	movw	r24, r28
     eb0:	41 96       	adiw	r24, 0x11	; 17
     eb2:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <xTaskRemoveFromEventList>
     eb6:	81 11       	cpse	r24, r1
     eb8:	0e 94 e1 0d 	call	0x1bc2	; 0x1bc2 <vTaskMissedYield>
     ebc:	11 50       	subi	r17, 0x01	; 1
     ebe:	11 16       	cp	r1, r17
     ec0:	9c f3       	brlt	.-26     	; 0xea8 <prvUnlockQueue+0x12>
     ec2:	8f ef       	ldi	r24, 0xFF	; 255
     ec4:	8e 8f       	std	Y+30, r24	; 0x1e
     ec6:	0f 90       	pop	r0
     ec8:	0f be       	out	0x3f, r0	; 63
     eca:	0f b6       	in	r0, 0x3f	; 63
     ecc:	f8 94       	cli
     ece:	0f 92       	push	r0
     ed0:	1d 8d       	ldd	r17, Y+29	; 0x1d
     ed2:	0b c0       	rjmp	.+22     	; 0xeea <prvUnlockQueue+0x54>
     ed4:	88 85       	ldd	r24, Y+8	; 0x08
     ed6:	88 23       	and	r24, r24
     ed8:	51 f0       	breq	.+20     	; 0xeee <prvUnlockQueue+0x58>
     eda:	ce 01       	movw	r24, r28
     edc:	08 96       	adiw	r24, 0x08	; 8
     ede:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <xTaskRemoveFromEventList>
     ee2:	81 11       	cpse	r24, r1
     ee4:	0e 94 e1 0d 	call	0x1bc2	; 0x1bc2 <vTaskMissedYield>
     ee8:	11 50       	subi	r17, 0x01	; 1
     eea:	11 16       	cp	r1, r17
     eec:	9c f3       	brlt	.-26     	; 0xed4 <prvUnlockQueue+0x3e>
     eee:	8f ef       	ldi	r24, 0xFF	; 255
     ef0:	8d 8f       	std	Y+29, r24	; 0x1d
     ef2:	0f 90       	pop	r0
     ef4:	0f be       	out	0x3f, r0	; 63
     ef6:	df 91       	pop	r29
     ef8:	cf 91       	pop	r28
     efa:	1f 91       	pop	r17
     efc:	08 95       	ret

00000efe <xQueueGenericReset>:
     efe:	cf 93       	push	r28
     f00:	df 93       	push	r29
     f02:	ec 01       	movw	r28, r24
     f04:	0f b6       	in	r0, 0x3f	; 63
     f06:	f8 94       	cli
     f08:	0f 92       	push	r0
     f0a:	e8 81       	ld	r30, Y
     f0c:	f9 81       	ldd	r31, Y+1	; 0x01
     f0e:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f10:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	30 e0       	ldi	r19, 0x00	; 0
     f16:	82 9f       	mul	r24, r18
     f18:	a0 01       	movw	r20, r0
     f1a:	83 9f       	mul	r24, r19
     f1c:	50 0d       	add	r21, r0
     f1e:	92 9f       	mul	r25, r18
     f20:	50 0d       	add	r21, r0
     f22:	11 24       	eor	r1, r1
     f24:	4e 0f       	add	r20, r30
     f26:	5f 1f       	adc	r21, r31
     f28:	5d 83       	std	Y+5, r21	; 0x05
     f2a:	4c 83       	std	Y+4, r20	; 0x04
     f2c:	1a 8e       	std	Y+26, r1	; 0x1a
     f2e:	fb 83       	std	Y+3, r31	; 0x03
     f30:	ea 83       	std	Y+2, r30	; 0x02
     f32:	01 97       	sbiw	r24, 0x01	; 1
     f34:	28 9f       	mul	r18, r24
     f36:	a0 01       	movw	r20, r0
     f38:	29 9f       	mul	r18, r25
     f3a:	50 0d       	add	r21, r0
     f3c:	38 9f       	mul	r19, r24
     f3e:	50 0d       	add	r21, r0
     f40:	11 24       	eor	r1, r1
     f42:	cf 01       	movw	r24, r30
     f44:	84 0f       	add	r24, r20
     f46:	95 1f       	adc	r25, r21
     f48:	9f 83       	std	Y+7, r25	; 0x07
     f4a:	8e 83       	std	Y+6, r24	; 0x06
     f4c:	8f ef       	ldi	r24, 0xFF	; 255
     f4e:	8d 8f       	std	Y+29, r24	; 0x1d
     f50:	8e 8f       	std	Y+30, r24	; 0x1e
     f52:	61 11       	cpse	r22, r1
     f54:	0c c0       	rjmp	.+24     	; 0xf6e <xQueueGenericReset+0x70>
     f56:	88 85       	ldd	r24, Y+8	; 0x08
     f58:	88 23       	and	r24, r24
     f5a:	89 f0       	breq	.+34     	; 0xf7e <xQueueGenericReset+0x80>
     f5c:	ce 01       	movw	r24, r28
     f5e:	08 96       	adiw	r24, 0x08	; 8
     f60:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <xTaskRemoveFromEventList>
     f64:	88 23       	and	r24, r24
     f66:	59 f0       	breq	.+22     	; 0xf7e <xQueueGenericReset+0x80>
     f68:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
     f6c:	08 c0       	rjmp	.+16     	; 0xf7e <xQueueGenericReset+0x80>
     f6e:	ce 01       	movw	r24, r28
     f70:	08 96       	adiw	r24, 0x08	; 8
     f72:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInitialise>
     f76:	ce 01       	movw	r24, r28
     f78:	41 96       	adiw	r24, 0x11	; 17
     f7a:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInitialise>
     f7e:	0f 90       	pop	r0
     f80:	0f be       	out	0x3f, r0	; 63
     f82:	81 e0       	ldi	r24, 0x01	; 1
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	08 95       	ret

00000f8a <prvInitialiseNewQueue>:
     f8a:	0f 93       	push	r16
     f8c:	1f 93       	push	r17
     f8e:	f8 01       	movw	r30, r16
     f90:	61 11       	cpse	r22, r1
     f92:	03 c0       	rjmp	.+6      	; 0xf9a <prvInitialiseNewQueue+0x10>
     f94:	11 83       	std	Z+1, r17	; 0x01
     f96:	00 83       	st	Z, r16
     f98:	02 c0       	rjmp	.+4      	; 0xf9e <prvInitialiseNewQueue+0x14>
     f9a:	51 83       	std	Z+1, r21	; 0x01
     f9c:	40 83       	st	Z, r20
     f9e:	83 8f       	std	Z+27, r24	; 0x1b
     fa0:	64 8f       	std	Z+28, r22	; 0x1c
     fa2:	61 e0       	ldi	r22, 0x01	; 1
     fa4:	cf 01       	movw	r24, r30
     fa6:	0e 94 7f 07 	call	0xefe	; 0xefe <xQueueGenericReset>
     faa:	1f 91       	pop	r17
     fac:	0f 91       	pop	r16
     fae:	08 95       	ret

00000fb0 <xQueueGenericCreate>:
     fb0:	df 92       	push	r13
     fb2:	ef 92       	push	r14
     fb4:	ff 92       	push	r15
     fb6:	0f 93       	push	r16
     fb8:	1f 93       	push	r17
     fba:	cf 93       	push	r28
     fbc:	df 93       	push	r29
     fbe:	e8 2e       	mov	r14, r24
     fc0:	f6 2e       	mov	r15, r22
     fc2:	d4 2e       	mov	r13, r20
     fc4:	66 23       	and	r22, r22
     fc6:	21 f0       	breq	.+8      	; 0xfd0 <xQueueGenericCreate+0x20>
     fc8:	86 9f       	mul	r24, r22
     fca:	c0 01       	movw	r24, r0
     fcc:	11 24       	eor	r1, r1
     fce:	02 c0       	rjmp	.+4      	; 0xfd4 <xQueueGenericCreate+0x24>
     fd0:	80 e0       	ldi	r24, 0x00	; 0
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	4f 96       	adiw	r24, 0x1f	; 31
     fd6:	0e 94 b0 04 	call	0x960	; 0x960 <pvPortMalloc>
     fda:	ec 01       	movw	r28, r24
     fdc:	00 97       	sbiw	r24, 0x00	; 0
     fde:	49 f0       	breq	.+18     	; 0xff2 <xQueueGenericCreate+0x42>
     fe0:	8c 01       	movw	r16, r24
     fe2:	2d 2d       	mov	r18, r13
     fe4:	ac 01       	movw	r20, r24
     fe6:	41 5e       	subi	r20, 0xE1	; 225
     fe8:	5f 4f       	sbci	r21, 0xFF	; 255
     fea:	6f 2d       	mov	r22, r15
     fec:	8e 2d       	mov	r24, r14
     fee:	0e 94 c5 07 	call	0xf8a	; 0xf8a <prvInitialiseNewQueue>
     ff2:	ce 01       	movw	r24, r28
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	1f 91       	pop	r17
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	ef 90       	pop	r14
    1000:	df 90       	pop	r13
    1002:	08 95       	ret

00001004 <xQueueGenericSend>:
    1004:	cf 92       	push	r12
    1006:	df 92       	push	r13
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	00 d0       	rcall	.+0      	; 0x1016 <xQueueGenericSend+0x12>
    1016:	00 d0       	rcall	.+0      	; 0x1018 <xQueueGenericSend+0x14>
    1018:	1f 92       	push	r1
    101a:	cd b7       	in	r28, 0x3d	; 61
    101c:	de b7       	in	r29, 0x3e	; 62
    101e:	8c 01       	movw	r16, r24
    1020:	7b 01       	movw	r14, r22
    1022:	5d 83       	std	Y+5, r21	; 0x05
    1024:	4c 83       	std	Y+4, r20	; 0x04
    1026:	c2 2e       	mov	r12, r18
    1028:	d1 2c       	mov	r13, r1
    102a:	0f b6       	in	r0, 0x3f	; 63
    102c:	f8 94       	cli
    102e:	0f 92       	push	r0
    1030:	f8 01       	movw	r30, r16
    1032:	92 8d       	ldd	r25, Z+26	; 0x1a
    1034:	83 8d       	ldd	r24, Z+27	; 0x1b
    1036:	98 17       	cp	r25, r24
    1038:	18 f0       	brcs	.+6      	; 0x1040 <xQueueGenericSend+0x3c>
    103a:	f2 e0       	ldi	r31, 0x02	; 2
    103c:	cf 12       	cpse	r12, r31
    103e:	19 c0       	rjmp	.+50     	; 0x1072 <xQueueGenericSend+0x6e>
    1040:	4c 2d       	mov	r20, r12
    1042:	b7 01       	movw	r22, r14
    1044:	c8 01       	movw	r24, r16
    1046:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <prvCopyDataToQueue>
    104a:	f8 01       	movw	r30, r16
    104c:	91 89       	ldd	r25, Z+17	; 0x11
    104e:	99 23       	and	r25, r25
    1050:	49 f0       	breq	.+18     	; 0x1064 <xQueueGenericSend+0x60>
    1052:	c8 01       	movw	r24, r16
    1054:	41 96       	adiw	r24, 0x11	; 17
    1056:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <xTaskRemoveFromEventList>
    105a:	88 23       	and	r24, r24
    105c:	31 f0       	breq	.+12     	; 0x106a <xQueueGenericSend+0x66>
    105e:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
    1062:	03 c0       	rjmp	.+6      	; 0x106a <xQueueGenericSend+0x66>
    1064:	81 11       	cpse	r24, r1
    1066:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
    106a:	0f 90       	pop	r0
    106c:	0f be       	out	0x3f, r0	; 63
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	4d c0       	rjmp	.+154    	; 0x110c <xQueueGenericSend+0x108>
    1072:	8c 81       	ldd	r24, Y+4	; 0x04
    1074:	9d 81       	ldd	r25, Y+5	; 0x05
    1076:	89 2b       	or	r24, r25
    1078:	21 f4       	brne	.+8      	; 0x1082 <xQueueGenericSend+0x7e>
    107a:	0f 90       	pop	r0
    107c:	0f be       	out	0x3f, r0	; 63
    107e:	80 e0       	ldi	r24, 0x00	; 0
    1080:	45 c0       	rjmp	.+138    	; 0x110c <xQueueGenericSend+0x108>
    1082:	d1 10       	cpse	r13, r1
    1084:	06 c0       	rjmp	.+12     	; 0x1092 <xQueueGenericSend+0x8e>
    1086:	ce 01       	movw	r24, r28
    1088:	01 96       	adiw	r24, 0x01	; 1
    108a:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <vTaskInternalSetTimeOutState>
    108e:	dd 24       	eor	r13, r13
    1090:	d3 94       	inc	r13
    1092:	0f 90       	pop	r0
    1094:	0f be       	out	0x3f, r0	; 63
    1096:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <vTaskSuspendAll>
    109a:	0f b6       	in	r0, 0x3f	; 63
    109c:	f8 94       	cli
    109e:	0f 92       	push	r0
    10a0:	f8 01       	movw	r30, r16
    10a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    10a4:	8f 3f       	cpi	r24, 0xFF	; 255
    10a6:	09 f4       	brne	.+2      	; 0x10aa <xQueueGenericSend+0xa6>
    10a8:	15 8e       	std	Z+29, r1	; 0x1d
    10aa:	f8 01       	movw	r30, r16
    10ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    10ae:	8f 3f       	cpi	r24, 0xFF	; 255
    10b0:	09 f4       	brne	.+2      	; 0x10b4 <xQueueGenericSend+0xb0>
    10b2:	16 8e       	std	Z+30, r1	; 0x1e
    10b4:	0f 90       	pop	r0
    10b6:	0f be       	out	0x3f, r0	; 63
    10b8:	be 01       	movw	r22, r28
    10ba:	6c 5f       	subi	r22, 0xFC	; 252
    10bc:	7f 4f       	sbci	r23, 0xFF	; 255
    10be:	ce 01       	movw	r24, r28
    10c0:	01 96       	adiw	r24, 0x01	; 1
    10c2:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskCheckForTimeOut>
    10c6:	81 11       	cpse	r24, r1
    10c8:	1b c0       	rjmp	.+54     	; 0x1100 <xQueueGenericSend+0xfc>
    10ca:	c8 01       	movw	r24, r16
    10cc:	0e 94 da 06 	call	0xdb4	; 0xdb4 <prvIsQueueFull>
    10d0:	88 23       	and	r24, r24
    10d2:	81 f0       	breq	.+32     	; 0x10f4 <xQueueGenericSend+0xf0>
    10d4:	6c 81       	ldd	r22, Y+4	; 0x04
    10d6:	7d 81       	ldd	r23, Y+5	; 0x05
    10d8:	c8 01       	movw	r24, r16
    10da:	08 96       	adiw	r24, 0x08	; 8
    10dc:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <vTaskPlaceOnEventList>
    10e0:	c8 01       	movw	r24, r16
    10e2:	0e 94 4b 07 	call	0xe96	; 0xe96 <prvUnlockQueue>
    10e6:	0e 94 12 0c 	call	0x1824	; 0x1824 <xTaskResumeAll>
    10ea:	81 11       	cpse	r24, r1
    10ec:	9e cf       	rjmp	.-196    	; 0x102a <xQueueGenericSend+0x26>
    10ee:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
    10f2:	9b cf       	rjmp	.-202    	; 0x102a <xQueueGenericSend+0x26>
    10f4:	c8 01       	movw	r24, r16
    10f6:	0e 94 4b 07 	call	0xe96	; 0xe96 <prvUnlockQueue>
    10fa:	0e 94 12 0c 	call	0x1824	; 0x1824 <xTaskResumeAll>
    10fe:	95 cf       	rjmp	.-214    	; 0x102a <xQueueGenericSend+0x26>
    1100:	c8 01       	movw	r24, r16
    1102:	0e 94 4b 07 	call	0xe96	; 0xe96 <prvUnlockQueue>
    1106:	0e 94 12 0c 	call	0x1824	; 0x1824 <xTaskResumeAll>
    110a:	80 e0       	ldi	r24, 0x00	; 0
    110c:	0f 90       	pop	r0
    110e:	0f 90       	pop	r0
    1110:	0f 90       	pop	r0
    1112:	0f 90       	pop	r0
    1114:	0f 90       	pop	r0
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	ff 90       	pop	r15
    1120:	ef 90       	pop	r14
    1122:	df 90       	pop	r13
    1124:	cf 90       	pop	r12
    1126:	08 95       	ret

00001128 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1128:	cf 92       	push	r12
    112a:	df 92       	push	r13
    112c:	ef 92       	push	r14
    112e:	ff 92       	push	r15
    1130:	0f 93       	push	r16
    1132:	1f 93       	push	r17
    1134:	cf 93       	push	r28
    1136:	df 93       	push	r29
    1138:	00 d0       	rcall	.+0      	; 0x113a <xQueueReceive+0x12>
    113a:	00 d0       	rcall	.+0      	; 0x113c <xQueueReceive+0x14>
    113c:	1f 92       	push	r1
    113e:	cd b7       	in	r28, 0x3d	; 61
    1140:	de b7       	in	r29, 0x3e	; 62
    1142:	8c 01       	movw	r16, r24
    1144:	6b 01       	movw	r12, r22
    1146:	5d 83       	std	Y+5, r21	; 0x05
    1148:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    114a:	e1 2c       	mov	r14, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1152:	f8 01       	movw	r30, r16
    1154:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1156:	ff 20       	and	r15, r15
    1158:	a9 f0       	breq	.+42     	; 0x1184 <xQueueReceive+0x5c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    115a:	b6 01       	movw	r22, r12
    115c:	c8 01       	movw	r24, r16
    115e:	0e 94 31 07 	call	0xe62	; 0xe62 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1162:	fa 94       	dec	r15
    1164:	f8 01       	movw	r30, r16
    1166:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1168:	80 85       	ldd	r24, Z+8	; 0x08
    116a:	88 23       	and	r24, r24
    116c:	39 f0       	breq	.+14     	; 0x117c <xQueueReceive+0x54>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    116e:	c8 01       	movw	r24, r16
    1170:	08 96       	adiw	r24, 0x08	; 8
    1172:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <xTaskRemoveFromEventList>
    1176:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1178:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    117c:	0f 90       	pop	r0
    117e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	53 c0       	rjmp	.+166    	; 0x122a <xQueueReceive+0x102>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1184:	8c 81       	ldd	r24, Y+4	; 0x04
    1186:	9d 81       	ldd	r25, Y+5	; 0x05
    1188:	89 2b       	or	r24, r25
    118a:	21 f4       	brne	.+8      	; 0x1194 <xQueueReceive+0x6c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    118c:	0f 90       	pop	r0
    118e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1190:	80 e0       	ldi	r24, 0x00	; 0
    1192:	4b c0       	rjmp	.+150    	; 0x122a <xQueueReceive+0x102>
				}
				else if( xEntryTimeSet == pdFALSE )
    1194:	e1 10       	cpse	r14, r1
    1196:	06 c0       	rjmp	.+12     	; 0x11a4 <xQueueReceive+0x7c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1198:	ce 01       	movw	r24, r28
    119a:	01 96       	adiw	r24, 0x01	; 1
    119c:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11a0:	ee 24       	eor	r14, r14
    11a2:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    11a4:	0f 90       	pop	r0
    11a6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11a8:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	0f 92       	push	r0
    11b2:	f8 01       	movw	r30, r16
    11b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    11b6:	8f 3f       	cpi	r24, 0xFF	; 255
    11b8:	09 f4       	brne	.+2      	; 0x11bc <xQueueReceive+0x94>
    11ba:	15 8e       	std	Z+29, r1	; 0x1d
    11bc:	f8 01       	movw	r30, r16
    11be:	86 8d       	ldd	r24, Z+30	; 0x1e
    11c0:	8f 3f       	cpi	r24, 0xFF	; 255
    11c2:	09 f4       	brne	.+2      	; 0x11c6 <xQueueReceive+0x9e>
    11c4:	16 8e       	std	Z+30, r1	; 0x1e
    11c6:	0f 90       	pop	r0
    11c8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    11ca:	be 01       	movw	r22, r28
    11cc:	6c 5f       	subi	r22, 0xFC	; 252
    11ce:	7f 4f       	sbci	r23, 0xFF	; 255
    11d0:	ce 01       	movw	r24, r28
    11d2:	01 96       	adiw	r24, 0x01	; 1
    11d4:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <xTaskCheckForTimeOut>
    11d8:	81 11       	cpse	r24, r1
    11da:	1b c0       	rjmp	.+54     	; 0x1212 <xQueueReceive+0xea>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    11dc:	c8 01       	movw	r24, r16
    11de:	0e 94 cd 06 	call	0xd9a	; 0xd9a <prvIsQueueEmpty>
    11e2:	88 23       	and	r24, r24
    11e4:	81 f0       	breq	.+32     	; 0x1206 <xQueueReceive+0xde>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    11e6:	6c 81       	ldd	r22, Y+4	; 0x04
    11e8:	7d 81       	ldd	r23, Y+5	; 0x05
    11ea:	c8 01       	movw	r24, r16
    11ec:	41 96       	adiw	r24, 0x11	; 17
    11ee:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    11f2:	c8 01       	movw	r24, r16
    11f4:	0e 94 4b 07 	call	0xe96	; 0xe96 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    11f8:	0e 94 12 0c 	call	0x1824	; 0x1824 <xTaskResumeAll>
    11fc:	81 11       	cpse	r24, r1
    11fe:	a6 cf       	rjmp	.-180    	; 0x114c <xQueueReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1200:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
    1204:	a3 cf       	rjmp	.-186    	; 0x114c <xQueueReceive+0x24>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1206:	c8 01       	movw	r24, r16
    1208:	0e 94 4b 07 	call	0xe96	; 0xe96 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    120c:	0e 94 12 0c 	call	0x1824	; 0x1824 <xTaskResumeAll>
    1210:	9d cf       	rjmp	.-198    	; 0x114c <xQueueReceive+0x24>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    1212:	c8 01       	movw	r24, r16
    1214:	0e 94 4b 07 	call	0xe96	; 0xe96 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1218:	0e 94 12 0c 	call	0x1824	; 0x1824 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    121c:	c8 01       	movw	r24, r16
    121e:	0e 94 cd 06 	call	0xd9a	; 0xd9a <prvIsQueueEmpty>
    1222:	88 23       	and	r24, r24
    1224:	09 f4       	brne	.+2      	; 0x1228 <xQueueReceive+0x100>
    1226:	92 cf       	rjmp	.-220    	; 0x114c <xQueueReceive+0x24>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1228:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    122a:	0f 90       	pop	r0
    122c:	0f 90       	pop	r0
    122e:	0f 90       	pop	r0
    1230:	0f 90       	pop	r0
    1232:	0f 90       	pop	r0
    1234:	df 91       	pop	r29
    1236:	cf 91       	pop	r28
    1238:	1f 91       	pop	r17
    123a:	0f 91       	pop	r16
    123c:	ff 90       	pop	r15
    123e:	ef 90       	pop	r14
    1240:	df 90       	pop	r13
    1242:	cf 90       	pop	r12
    1244:	08 95       	ret

00001246 <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    1246:	e0 91 f8 06 	lds	r30, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    124a:	f0 91 f9 06 	lds	r31, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    124e:	80 81       	ld	r24, Z
    1250:	81 11       	cpse	r24, r1
    1252:	07 c0       	rjmp	.+14     	; 0x1262 <prvResetNextTaskUnblockTime+0x1c>
    1254:	8f ef       	ldi	r24, 0xFF	; 255
    1256:	9f ef       	ldi	r25, 0xFF	; 255
    1258:	90 93 d0 06 	sts	0x06D0, r25	; 0x8006d0 <xNextTaskUnblockTime+0x1>
    125c:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <xNextTaskUnblockTime>
    1260:	08 95       	ret
    1262:	e0 91 f8 06 	lds	r30, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    1266:	f0 91 f9 06 	lds	r31, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    126a:	05 80       	ldd	r0, Z+5	; 0x05
    126c:	f6 81       	ldd	r31, Z+6	; 0x06
    126e:	e0 2d       	mov	r30, r0
    1270:	06 80       	ldd	r0, Z+6	; 0x06
    1272:	f7 81       	ldd	r31, Z+7	; 0x07
    1274:	e0 2d       	mov	r30, r0
    1276:	82 81       	ldd	r24, Z+2	; 0x02
    1278:	93 81       	ldd	r25, Z+3	; 0x03
    127a:	90 93 d0 06 	sts	0x06D0, r25	; 0x8006d0 <xNextTaskUnblockTime+0x1>
    127e:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <xNextTaskUnblockTime>
    1282:	08 95       	ret

00001284 <prvDeleteTCB>:
    1284:	cf 93       	push	r28
    1286:	df 93       	push	r29
    1288:	ec 01       	movw	r28, r24
    128a:	8f 89       	ldd	r24, Y+23	; 0x17
    128c:	98 8d       	ldd	r25, Y+24	; 0x18
    128e:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vPortFree>
    1292:	ce 01       	movw	r24, r28
    1294:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vPortFree>
    1298:	df 91       	pop	r29
    129a:	cf 91       	pop	r28
    129c:	08 95       	ret

0000129e <prvInitialiseNewTask>:
    129e:	6f 92       	push	r6
    12a0:	7f 92       	push	r7
    12a2:	8f 92       	push	r8
    12a4:	9f 92       	push	r9
    12a6:	af 92       	push	r10
    12a8:	bf 92       	push	r11
    12aa:	cf 92       	push	r12
    12ac:	df 92       	push	r13
    12ae:	ef 92       	push	r14
    12b0:	0f 93       	push	r16
    12b2:	1f 93       	push	r17
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	cd b7       	in	r28, 0x3d	; 61
    12ba:	de b7       	in	r29, 0x3e	; 62
    12bc:	4c 01       	movw	r8, r24
    12be:	f5 01       	movw	r30, r10
    12c0:	87 89       	ldd	r24, Z+23	; 0x17
    12c2:	90 8d       	ldd	r25, Z+24	; 0x18
    12c4:	21 50       	subi	r18, 0x01	; 1
    12c6:	31 09       	sbc	r19, r1
    12c8:	3c 01       	movw	r6, r24
    12ca:	62 0e       	add	r6, r18
    12cc:	73 1e       	adc	r7, r19
    12ce:	61 15       	cp	r22, r1
    12d0:	71 05       	cpc	r23, r1
    12d2:	89 f4       	brne	.+34     	; 0x12f6 <prvInitialiseNewTask+0x58>
    12d4:	16 c0       	rjmp	.+44     	; 0x1302 <prvInitialiseNewTask+0x64>
    12d6:	82 2f       	mov	r24, r18
    12d8:	90 e0       	ldi	r25, 0x00	; 0
    12da:	fb 01       	movw	r30, r22
    12dc:	e8 0f       	add	r30, r24
    12de:	f9 1f       	adc	r31, r25
    12e0:	30 81       	ld	r19, Z
    12e2:	d5 01       	movw	r26, r10
    12e4:	a8 0f       	add	r26, r24
    12e6:	b9 1f       	adc	r27, r25
    12e8:	59 96       	adiw	r26, 0x19	; 25
    12ea:	3c 93       	st	X, r19
    12ec:	80 81       	ld	r24, Z
    12ee:	88 23       	and	r24, r24
    12f0:	29 f0       	breq	.+10     	; 0x12fc <prvInitialiseNewTask+0x5e>
    12f2:	2f 5f       	subi	r18, 0xFF	; 255
    12f4:	01 c0       	rjmp	.+2      	; 0x12f8 <prvInitialiseNewTask+0x5a>
    12f6:	20 e0       	ldi	r18, 0x00	; 0
    12f8:	28 30       	cpi	r18, 0x08	; 8
    12fa:	68 f3       	brcs	.-38     	; 0x12d6 <prvInitialiseNewTask+0x38>
    12fc:	f5 01       	movw	r30, r10
    12fe:	10 a2       	std	Z+32, r1	; 0x20
    1300:	02 c0       	rjmp	.+4      	; 0x1306 <prvInitialiseNewTask+0x68>
    1302:	f5 01       	movw	r30, r10
    1304:	11 8e       	std	Z+25, r1	; 0x19
    1306:	f3 e0       	ldi	r31, 0x03	; 3
    1308:	fe 15       	cp	r31, r14
    130a:	20 f4       	brcc	.+8      	; 0x1314 <prvInitialiseNewTask+0x76>
    130c:	0f 2e       	mov	r0, r31
    130e:	f3 e0       	ldi	r31, 0x03	; 3
    1310:	ef 2e       	mov	r14, r31
    1312:	f0 2d       	mov	r31, r0
    1314:	f5 01       	movw	r30, r10
    1316:	e6 8a       	std	Z+22, r14	; 0x16
    1318:	c5 01       	movw	r24, r10
    131a:	02 96       	adiw	r24, 0x02	; 2
    131c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <vListInitialiseItem>
    1320:	c5 01       	movw	r24, r10
    1322:	0c 96       	adiw	r24, 0x0c	; 12
    1324:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <vListInitialiseItem>
    1328:	f5 01       	movw	r30, r10
    132a:	b1 86       	std	Z+9, r11	; 0x09
    132c:	a0 86       	std	Z+8, r10	; 0x08
    132e:	84 e0       	ldi	r24, 0x04	; 4
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	8e 19       	sub	r24, r14
    1334:	91 09       	sbc	r25, r1
    1336:	95 87       	std	Z+13, r25	; 0x0d
    1338:	84 87       	std	Z+12, r24	; 0x0c
    133a:	b3 8a       	std	Z+19, r11	; 0x13
    133c:	a2 8a       	std	Z+18, r10	; 0x12
    133e:	11 a2       	std	Z+33, r1	; 0x21
    1340:	12 a2       	std	Z+34, r1	; 0x22
    1342:	13 a2       	std	Z+35, r1	; 0x23
    1344:	14 a2       	std	Z+36, r1	; 0x24
    1346:	15 a2       	std	Z+37, r1	; 0x25
    1348:	a8 01       	movw	r20, r16
    134a:	b4 01       	movw	r22, r8
    134c:	c3 01       	movw	r24, r6
    134e:	0e 94 7a 05 	call	0xaf4	; 0xaf4 <pxPortInitialiseStack>
    1352:	f5 01       	movw	r30, r10
    1354:	91 83       	std	Z+1, r25	; 0x01
    1356:	80 83       	st	Z, r24
    1358:	c1 14       	cp	r12, r1
    135a:	d1 04       	cpc	r13, r1
    135c:	19 f0       	breq	.+6      	; 0x1364 <prvInitialiseNewTask+0xc6>
    135e:	f6 01       	movw	r30, r12
    1360:	b1 82       	std	Z+1, r11	; 0x01
    1362:	a0 82       	st	Z, r10
    1364:	df 91       	pop	r29
    1366:	cf 91       	pop	r28
    1368:	1f 91       	pop	r17
    136a:	0f 91       	pop	r16
    136c:	ef 90       	pop	r14
    136e:	df 90       	pop	r13
    1370:	cf 90       	pop	r12
    1372:	bf 90       	pop	r11
    1374:	af 90       	pop	r10
    1376:	9f 90       	pop	r9
    1378:	8f 90       	pop	r8
    137a:	7f 90       	pop	r7
    137c:	6f 90       	pop	r6
    137e:	08 95       	ret

00001380 <prvInitialiseTaskLists>:
    1380:	cf 93       	push	r28
    1382:	c0 e0       	ldi	r28, 0x00	; 0
    1384:	10 c0       	rjmp	.+32     	; 0x13a6 <prvInitialiseTaskLists+0x26>
    1386:	8c 2f       	mov	r24, r28
    1388:	90 e0       	ldi	r25, 0x00	; 0
    138a:	9c 01       	movw	r18, r24
    138c:	22 0f       	add	r18, r18
    138e:	33 1f       	adc	r19, r19
    1390:	22 0f       	add	r18, r18
    1392:	33 1f       	adc	r19, r19
    1394:	22 0f       	add	r18, r18
    1396:	33 1f       	adc	r19, r19
    1398:	82 0f       	add	r24, r18
    139a:	93 1f       	adc	r25, r19
    139c:	84 5f       	subi	r24, 0xF4	; 244
    139e:	98 4f       	sbci	r25, 0xF8	; 248
    13a0:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInitialise>
    13a4:	cf 5f       	subi	r28, 0xFF	; 255
    13a6:	c4 30       	cpi	r28, 0x04	; 4
    13a8:	70 f3       	brcs	.-36     	; 0x1386 <prvInitialiseTaskLists+0x6>
    13aa:	83 e0       	ldi	r24, 0x03	; 3
    13ac:	97 e0       	ldi	r25, 0x07	; 7
    13ae:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInitialise>
    13b2:	8a ef       	ldi	r24, 0xFA	; 250
    13b4:	96 e0       	ldi	r25, 0x06	; 6
    13b6:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInitialise>
    13ba:	8d ee       	ldi	r24, 0xED	; 237
    13bc:	96 e0       	ldi	r25, 0x06	; 6
    13be:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInitialise>
    13c2:	84 ee       	ldi	r24, 0xE4	; 228
    13c4:	96 e0       	ldi	r25, 0x06	; 6
    13c6:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInitialise>
    13ca:	8a ed       	ldi	r24, 0xDA	; 218
    13cc:	96 e0       	ldi	r25, 0x06	; 6
    13ce:	0e 94 e6 04 	call	0x9cc	; 0x9cc <vListInitialise>
    13d2:	83 e0       	ldi	r24, 0x03	; 3
    13d4:	97 e0       	ldi	r25, 0x07	; 7
    13d6:	90 93 f9 06 	sts	0x06F9, r25	; 0x8006f9 <pxDelayedTaskList+0x1>
    13da:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <pxDelayedTaskList>
    13de:	8a ef       	ldi	r24, 0xFA	; 250
    13e0:	96 e0       	ldi	r25, 0x06	; 6
    13e2:	90 93 f7 06 	sts	0x06F7, r25	; 0x8006f7 <pxOverflowDelayedTaskList+0x1>
    13e6:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <pxOverflowDelayedTaskList>
    13ea:	cf 91       	pop	r28
    13ec:	08 95       	ret

000013ee <prvAddNewTaskToReadyList>:
    13ee:	cf 93       	push	r28
    13f0:	df 93       	push	r29
    13f2:	ec 01       	movw	r28, r24
    13f4:	0f b6       	in	r0, 0x3f	; 63
    13f6:	f8 94       	cli
    13f8:	0f 92       	push	r0
    13fa:	80 91 d9 06 	lds	r24, 0x06D9	; 0x8006d9 <uxCurrentNumberOfTasks>
    13fe:	8f 5f       	subi	r24, 0xFF	; 255
    1400:	80 93 d9 06 	sts	0x06D9, r24	; 0x8006d9 <uxCurrentNumberOfTasks>
    1404:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <pxCurrentTCB>
    1408:	90 91 31 07 	lds	r25, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    140c:	89 2b       	or	r24, r25
    140e:	59 f4       	brne	.+22     	; 0x1426 <prvAddNewTaskToReadyList+0x38>
    1410:	d0 93 31 07 	sts	0x0731, r29	; 0x800731 <pxCurrentTCB+0x1>
    1414:	c0 93 30 07 	sts	0x0730, r28	; 0x800730 <pxCurrentTCB>
    1418:	80 91 d9 06 	lds	r24, 0x06D9	; 0x8006d9 <uxCurrentNumberOfTasks>
    141c:	81 30       	cpi	r24, 0x01	; 1
    141e:	99 f4       	brne	.+38     	; 0x1446 <prvAddNewTaskToReadyList+0x58>
    1420:	0e 94 c0 09 	call	0x1380	; 0x1380 <prvInitialiseTaskLists>
    1424:	10 c0       	rjmp	.+32     	; 0x1446 <prvAddNewTaskToReadyList+0x58>
    1426:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <xSchedulerRunning>
    142a:	81 11       	cpse	r24, r1
    142c:	0c c0       	rjmp	.+24     	; 0x1446 <prvAddNewTaskToReadyList+0x58>
    142e:	e0 91 30 07 	lds	r30, 0x0730	; 0x800730 <pxCurrentTCB>
    1432:	f0 91 31 07 	lds	r31, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    1436:	96 89       	ldd	r25, Z+22	; 0x16
    1438:	8e 89       	ldd	r24, Y+22	; 0x16
    143a:	89 17       	cp	r24, r25
    143c:	20 f0       	brcs	.+8      	; 0x1446 <prvAddNewTaskToReadyList+0x58>
    143e:	d0 93 31 07 	sts	0x0731, r29	; 0x800731 <pxCurrentTCB+0x1>
    1442:	c0 93 30 07 	sts	0x0730, r28	; 0x800730 <pxCurrentTCB>
    1446:	80 91 d1 06 	lds	r24, 0x06D1	; 0x8006d1 <uxTaskNumber>
    144a:	8f 5f       	subi	r24, 0xFF	; 255
    144c:	80 93 d1 06 	sts	0x06D1, r24	; 0x8006d1 <uxTaskNumber>
    1450:	8e 89       	ldd	r24, Y+22	; 0x16
    1452:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <uxTopReadyPriority>
    1456:	98 17       	cp	r25, r24
    1458:	10 f4       	brcc	.+4      	; 0x145e <prvAddNewTaskToReadyList+0x70>
    145a:	80 93 d6 06 	sts	0x06D6, r24	; 0x8006d6 <uxTopReadyPriority>
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	9c 01       	movw	r18, r24
    1462:	22 0f       	add	r18, r18
    1464:	33 1f       	adc	r19, r19
    1466:	22 0f       	add	r18, r18
    1468:	33 1f       	adc	r19, r19
    146a:	22 0f       	add	r18, r18
    146c:	33 1f       	adc	r19, r19
    146e:	82 0f       	add	r24, r18
    1470:	93 1f       	adc	r25, r19
    1472:	be 01       	movw	r22, r28
    1474:	6e 5f       	subi	r22, 0xFE	; 254
    1476:	7f 4f       	sbci	r23, 0xFF	; 255
    1478:	84 5f       	subi	r24, 0xF4	; 244
    147a:	98 4f       	sbci	r25, 0xF8	; 248
    147c:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <vListInsertEnd>
    1480:	0f 90       	pop	r0
    1482:	0f be       	out	0x3f, r0	; 63
    1484:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <xSchedulerRunning>
    1488:	88 23       	and	r24, r24
    148a:	51 f0       	breq	.+20     	; 0x14a0 <prvAddNewTaskToReadyList+0xb2>
    148c:	e0 91 30 07 	lds	r30, 0x0730	; 0x800730 <pxCurrentTCB>
    1490:	f0 91 31 07 	lds	r31, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    1494:	96 89       	ldd	r25, Z+22	; 0x16
    1496:	8e 89       	ldd	r24, Y+22	; 0x16
    1498:	98 17       	cp	r25, r24
    149a:	10 f4       	brcc	.+4      	; 0x14a0 <prvAddNewTaskToReadyList+0xb2>
    149c:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
    14a0:	df 91       	pop	r29
    14a2:	cf 91       	pop	r28
    14a4:	08 95       	ret

000014a6 <prvCheckTasksWaitingTermination>:
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	1c c0       	rjmp	.+56     	; 0x14e4 <prvCheckTasksWaitingTermination+0x3e>
    14ac:	0f b6       	in	r0, 0x3f	; 63
    14ae:	f8 94       	cli
    14b0:	0f 92       	push	r0
    14b2:	e0 91 e9 06 	lds	r30, 0x06E9	; 0x8006e9 <xTasksWaitingTermination+0x5>
    14b6:	f0 91 ea 06 	lds	r31, 0x06EA	; 0x8006ea <xTasksWaitingTermination+0x6>
    14ba:	c6 81       	ldd	r28, Z+6	; 0x06
    14bc:	d7 81       	ldd	r29, Z+7	; 0x07
    14be:	ce 01       	movw	r24, r28
    14c0:	02 96       	adiw	r24, 0x02	; 2
    14c2:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    14c6:	80 91 d9 06 	lds	r24, 0x06D9	; 0x8006d9 <uxCurrentNumberOfTasks>
    14ca:	81 50       	subi	r24, 0x01	; 1
    14cc:	80 93 d9 06 	sts	0x06D9, r24	; 0x8006d9 <uxCurrentNumberOfTasks>
    14d0:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <uxDeletedTasksWaitingCleanUp>
    14d4:	81 50       	subi	r24, 0x01	; 1
    14d6:	80 93 e3 06 	sts	0x06E3, r24	; 0x8006e3 <uxDeletedTasksWaitingCleanUp>
    14da:	0f 90       	pop	r0
    14dc:	0f be       	out	0x3f, r0	; 63
    14de:	ce 01       	movw	r24, r28
    14e0:	0e 94 42 09 	call	0x1284	; 0x1284 <prvDeleteTCB>
    14e4:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <uxDeletedTasksWaitingCleanUp>
    14e8:	81 11       	cpse	r24, r1
    14ea:	e0 cf       	rjmp	.-64     	; 0x14ac <prvCheckTasksWaitingTermination+0x6>
    14ec:	df 91       	pop	r29
    14ee:	cf 91       	pop	r28
    14f0:	08 95       	ret

000014f2 <prvIdleTask>:
    14f2:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <prvCheckTasksWaitingTermination>
    14f6:	fd cf       	rjmp	.-6      	; 0x14f2 <prvIdleTask>

000014f8 <prvAddCurrentTaskToDelayedList>:
    14f8:	ff 92       	push	r15
    14fa:	0f 93       	push	r16
    14fc:	1f 93       	push	r17
    14fe:	cf 93       	push	r28
    1500:	df 93       	push	r29
    1502:	ec 01       	movw	r28, r24
    1504:	f6 2e       	mov	r15, r22
    1506:	00 91 d7 06 	lds	r16, 0x06D7	; 0x8006d7 <xTickCount>
    150a:	10 91 d8 06 	lds	r17, 0x06D8	; 0x8006d8 <xTickCount+0x1>
    150e:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <pxCurrentTCB>
    1512:	90 91 31 07 	lds	r25, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    1516:	02 96       	adiw	r24, 0x02	; 2
    1518:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    151c:	cf 3f       	cpi	r28, 0xFF	; 255
    151e:	8f ef       	ldi	r24, 0xFF	; 255
    1520:	d8 07       	cpc	r29, r24
    1522:	69 f4       	brne	.+26     	; 0x153e <prvAddCurrentTaskToDelayedList+0x46>
    1524:	ff 20       	and	r15, r15
    1526:	59 f0       	breq	.+22     	; 0x153e <prvAddCurrentTaskToDelayedList+0x46>
    1528:	60 91 30 07 	lds	r22, 0x0730	; 0x800730 <pxCurrentTCB>
    152c:	70 91 31 07 	lds	r23, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    1530:	6e 5f       	subi	r22, 0xFE	; 254
    1532:	7f 4f       	sbci	r23, 0xFF	; 255
    1534:	8a ed       	ldi	r24, 0xDA	; 218
    1536:	96 e0       	ldi	r25, 0x06	; 6
    1538:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <vListInsertEnd>
    153c:	2f c0       	rjmp	.+94     	; 0x159c <prvAddCurrentTaskToDelayedList+0xa4>
    153e:	c0 0f       	add	r28, r16
    1540:	d1 1f       	adc	r29, r17
    1542:	e0 91 30 07 	lds	r30, 0x0730	; 0x800730 <pxCurrentTCB>
    1546:	f0 91 31 07 	lds	r31, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    154a:	d3 83       	std	Z+3, r29	; 0x03
    154c:	c2 83       	std	Z+2, r28	; 0x02
    154e:	c0 17       	cp	r28, r16
    1550:	d1 07       	cpc	r29, r17
    1552:	68 f4       	brcc	.+26     	; 0x156e <prvAddCurrentTaskToDelayedList+0x76>
    1554:	60 91 30 07 	lds	r22, 0x0730	; 0x800730 <pxCurrentTCB>
    1558:	70 91 31 07 	lds	r23, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    155c:	80 91 f6 06 	lds	r24, 0x06F6	; 0x8006f6 <pxOverflowDelayedTaskList>
    1560:	90 91 f7 06 	lds	r25, 0x06F7	; 0x8006f7 <pxOverflowDelayedTaskList+0x1>
    1564:	6e 5f       	subi	r22, 0xFE	; 254
    1566:	7f 4f       	sbci	r23, 0xFF	; 255
    1568:	0e 94 19 05 	call	0xa32	; 0xa32 <vListInsert>
    156c:	17 c0       	rjmp	.+46     	; 0x159c <prvAddCurrentTaskToDelayedList+0xa4>
    156e:	60 91 30 07 	lds	r22, 0x0730	; 0x800730 <pxCurrentTCB>
    1572:	70 91 31 07 	lds	r23, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    1576:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    157a:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    157e:	6e 5f       	subi	r22, 0xFE	; 254
    1580:	7f 4f       	sbci	r23, 0xFF	; 255
    1582:	0e 94 19 05 	call	0xa32	; 0xa32 <vListInsert>
    1586:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <xNextTaskUnblockTime>
    158a:	90 91 d0 06 	lds	r25, 0x06D0	; 0x8006d0 <xNextTaskUnblockTime+0x1>
    158e:	c8 17       	cp	r28, r24
    1590:	d9 07       	cpc	r29, r25
    1592:	20 f4       	brcc	.+8      	; 0x159c <prvAddCurrentTaskToDelayedList+0xa4>
    1594:	d0 93 d0 06 	sts	0x06D0, r29	; 0x8006d0 <xNextTaskUnblockTime+0x1>
    1598:	c0 93 cf 06 	sts	0x06CF, r28	; 0x8006cf <xNextTaskUnblockTime>
    159c:	df 91       	pop	r29
    159e:	cf 91       	pop	r28
    15a0:	1f 91       	pop	r17
    15a2:	0f 91       	pop	r16
    15a4:	ff 90       	pop	r15
    15a6:	08 95       	ret

000015a8 <xTaskCreate>:
    15a8:	2f 92       	push	r2
    15aa:	3f 92       	push	r3
    15ac:	4f 92       	push	r4
    15ae:	5f 92       	push	r5
    15b0:	6f 92       	push	r6
    15b2:	7f 92       	push	r7
    15b4:	8f 92       	push	r8
    15b6:	9f 92       	push	r9
    15b8:	af 92       	push	r10
    15ba:	bf 92       	push	r11
    15bc:	cf 92       	push	r12
    15be:	df 92       	push	r13
    15c0:	ef 92       	push	r14
    15c2:	ff 92       	push	r15
    15c4:	0f 93       	push	r16
    15c6:	1f 93       	push	r17
    15c8:	cf 93       	push	r28
    15ca:	df 93       	push	r29
    15cc:	3c 01       	movw	r6, r24
    15ce:	1b 01       	movw	r2, r22
    15d0:	5a 01       	movw	r10, r20
    15d2:	29 01       	movw	r4, r18
    15d4:	ca 01       	movw	r24, r20
    15d6:	0e 94 b0 04 	call	0x960	; 0x960 <pvPortMalloc>
    15da:	6c 01       	movw	r12, r24
    15dc:	89 2b       	or	r24, r25
    15de:	71 f0       	breq	.+28     	; 0x15fc <xTaskCreate+0x54>
    15e0:	86 e2       	ldi	r24, 0x26	; 38
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	0e 94 b0 04 	call	0x960	; 0x960 <pvPortMalloc>
    15e8:	ec 01       	movw	r28, r24
    15ea:	89 2b       	or	r24, r25
    15ec:	19 f0       	breq	.+6      	; 0x15f4 <xTaskCreate+0x4c>
    15ee:	d8 8e       	std	Y+24, r13	; 0x18
    15f0:	cf 8a       	std	Y+23, r12	; 0x17
    15f2:	06 c0       	rjmp	.+12     	; 0x1600 <xTaskCreate+0x58>
    15f4:	c6 01       	movw	r24, r12
    15f6:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vPortFree>
    15fa:	02 c0       	rjmp	.+4      	; 0x1600 <xTaskCreate+0x58>
    15fc:	c0 e0       	ldi	r28, 0x00	; 0
    15fe:	d0 e0       	ldi	r29, 0x00	; 0
    1600:	20 97       	sbiw	r28, 0x00	; 0
    1602:	91 f0       	breq	.+36     	; 0x1628 <xTaskCreate+0x80>
    1604:	95 01       	movw	r18, r10
    1606:	40 e0       	ldi	r20, 0x00	; 0
    1608:	50 e0       	ldi	r21, 0x00	; 0
    160a:	81 2c       	mov	r8, r1
    160c:	91 2c       	mov	r9, r1
    160e:	5e 01       	movw	r10, r28
    1610:	67 01       	movw	r12, r14
    1612:	e0 2e       	mov	r14, r16
    1614:	82 01       	movw	r16, r4
    1616:	b1 01       	movw	r22, r2
    1618:	c3 01       	movw	r24, r6
    161a:	0e 94 4f 09 	call	0x129e	; 0x129e <prvInitialiseNewTask>
    161e:	ce 01       	movw	r24, r28
    1620:	0e 94 f7 09 	call	0x13ee	; 0x13ee <prvAddNewTaskToReadyList>
    1624:	81 e0       	ldi	r24, 0x01	; 1
    1626:	01 c0       	rjmp	.+2      	; 0x162a <xTaskCreate+0x82>
    1628:	8f ef       	ldi	r24, 0xFF	; 255
    162a:	df 91       	pop	r29
    162c:	cf 91       	pop	r28
    162e:	1f 91       	pop	r17
    1630:	0f 91       	pop	r16
    1632:	ff 90       	pop	r15
    1634:	ef 90       	pop	r14
    1636:	df 90       	pop	r13
    1638:	cf 90       	pop	r12
    163a:	bf 90       	pop	r11
    163c:	af 90       	pop	r10
    163e:	9f 90       	pop	r9
    1640:	8f 90       	pop	r8
    1642:	7f 90       	pop	r7
    1644:	6f 90       	pop	r6
    1646:	5f 90       	pop	r5
    1648:	4f 90       	pop	r4
    164a:	3f 90       	pop	r3
    164c:	2f 90       	pop	r2
    164e:	08 95       	ret

00001650 <vTaskStartScheduler>:
    1650:	ef 92       	push	r14
    1652:	ff 92       	push	r15
    1654:	0f 93       	push	r16
    1656:	0f 2e       	mov	r0, r31
    1658:	fd ec       	ldi	r31, 0xCD	; 205
    165a:	ef 2e       	mov	r14, r31
    165c:	f6 e0       	ldi	r31, 0x06	; 6
    165e:	ff 2e       	mov	r15, r31
    1660:	f0 2d       	mov	r31, r0
    1662:	00 e0       	ldi	r16, 0x00	; 0
    1664:	20 e0       	ldi	r18, 0x00	; 0
    1666:	30 e0       	ldi	r19, 0x00	; 0
    1668:	45 e5       	ldi	r20, 0x55	; 85
    166a:	50 e0       	ldi	r21, 0x00	; 0
    166c:	6d e9       	ldi	r22, 0x9D	; 157
    166e:	70 e0       	ldi	r23, 0x00	; 0
    1670:	89 e7       	ldi	r24, 0x79	; 121
    1672:	9a e0       	ldi	r25, 0x0A	; 10
    1674:	0e 94 d4 0a 	call	0x15a8	; 0x15a8 <xTaskCreate>
    1678:	81 30       	cpi	r24, 0x01	; 1
    167a:	81 f4       	brne	.+32     	; 0x169c <vTaskStartScheduler+0x4c>
    167c:	f8 94       	cli
    167e:	8f ef       	ldi	r24, 0xFF	; 255
    1680:	9f ef       	ldi	r25, 0xFF	; 255
    1682:	90 93 d0 06 	sts	0x06D0, r25	; 0x8006d0 <xNextTaskUnblockTime+0x1>
    1686:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <xNextTaskUnblockTime>
    168a:	81 e0       	ldi	r24, 0x01	; 1
    168c:	80 93 d5 06 	sts	0x06D5, r24	; 0x8006d5 <xSchedulerRunning>
    1690:	10 92 d8 06 	sts	0x06D8, r1	; 0x8006d8 <xTickCount+0x1>
    1694:	10 92 d7 06 	sts	0x06D7, r1	; 0x8006d7 <xTickCount>
    1698:	0e 94 e6 05 	call	0xbcc	; 0xbcc <xPortStartScheduler>
    169c:	0f 91       	pop	r16
    169e:	ff 90       	pop	r15
    16a0:	ef 90       	pop	r14
    16a2:	08 95       	ret

000016a4 <vTaskSuspendAll>:
    16a4:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <uxSchedulerSuspended>
    16a8:	8f 5f       	subi	r24, 0xFF	; 255
    16aa:	80 93 cc 06 	sts	0x06CC, r24	; 0x8006cc <uxSchedulerSuspended>
    16ae:	08 95       	ret

000016b0 <xTaskIncrementTick>:
    16b0:	df 92       	push	r13
    16b2:	ef 92       	push	r14
    16b4:	ff 92       	push	r15
    16b6:	0f 93       	push	r16
    16b8:	1f 93       	push	r17
    16ba:	cf 93       	push	r28
    16bc:	df 93       	push	r29
    16be:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <uxSchedulerSuspended>
    16c2:	81 11       	cpse	r24, r1
    16c4:	97 c0       	rjmp	.+302    	; 0x17f4 <xTaskIncrementTick+0x144>
    16c6:	e0 90 d7 06 	lds	r14, 0x06D7	; 0x8006d7 <xTickCount>
    16ca:	f0 90 d8 06 	lds	r15, 0x06D8	; 0x8006d8 <xTickCount+0x1>
    16ce:	8f ef       	ldi	r24, 0xFF	; 255
    16d0:	e8 1a       	sub	r14, r24
    16d2:	f8 0a       	sbc	r15, r24
    16d4:	f0 92 d8 06 	sts	0x06D8, r15	; 0x8006d8 <xTickCount+0x1>
    16d8:	e0 92 d7 06 	sts	0x06D7, r14	; 0x8006d7 <xTickCount>
    16dc:	e1 14       	cp	r14, r1
    16de:	f1 04       	cpc	r15, r1
    16e0:	b9 f4       	brne	.+46     	; 0x1710 <xTaskIncrementTick+0x60>
    16e2:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    16e6:	90 91 f9 06 	lds	r25, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    16ea:	20 91 f6 06 	lds	r18, 0x06F6	; 0x8006f6 <pxOverflowDelayedTaskList>
    16ee:	30 91 f7 06 	lds	r19, 0x06F7	; 0x8006f7 <pxOverflowDelayedTaskList+0x1>
    16f2:	30 93 f9 06 	sts	0x06F9, r19	; 0x8006f9 <pxDelayedTaskList+0x1>
    16f6:	20 93 f8 06 	sts	0x06F8, r18	; 0x8006f8 <pxDelayedTaskList>
    16fa:	90 93 f7 06 	sts	0x06F7, r25	; 0x8006f7 <pxOverflowDelayedTaskList+0x1>
    16fe:	80 93 f6 06 	sts	0x06F6, r24	; 0x8006f6 <pxOverflowDelayedTaskList>
    1702:	80 91 d2 06 	lds	r24, 0x06D2	; 0x8006d2 <xNumOfOverflows>
    1706:	8f 5f       	subi	r24, 0xFF	; 255
    1708:	80 93 d2 06 	sts	0x06D2, r24	; 0x8006d2 <xNumOfOverflows>
    170c:	0e 94 23 09 	call	0x1246	; 0x1246 <prvResetNextTaskUnblockTime>
    1710:	80 91 cf 06 	lds	r24, 0x06CF	; 0x8006cf <xNextTaskUnblockTime>
    1714:	90 91 d0 06 	lds	r25, 0x06D0	; 0x8006d0 <xNextTaskUnblockTime+0x1>
    1718:	e8 16       	cp	r14, r24
    171a:	f9 06       	cpc	r15, r25
    171c:	28 f4       	brcc	.+10     	; 0x1728 <xTaskIncrementTick+0x78>
    171e:	d1 2c       	mov	r13, r1
    1720:	53 c0       	rjmp	.+166    	; 0x17c8 <xTaskIncrementTick+0x118>
    1722:	dd 24       	eor	r13, r13
    1724:	d3 94       	inc	r13
    1726:	01 c0       	rjmp	.+2      	; 0x172a <xTaskIncrementTick+0x7a>
    1728:	d1 2c       	mov	r13, r1
    172a:	e0 91 f8 06 	lds	r30, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    172e:	f0 91 f9 06 	lds	r31, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    1732:	80 81       	ld	r24, Z
    1734:	81 11       	cpse	r24, r1
    1736:	07 c0       	rjmp	.+14     	; 0x1746 <xTaskIncrementTick+0x96>
    1738:	8f ef       	ldi	r24, 0xFF	; 255
    173a:	9f ef       	ldi	r25, 0xFF	; 255
    173c:	90 93 d0 06 	sts	0x06D0, r25	; 0x8006d0 <xNextTaskUnblockTime+0x1>
    1740:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <xNextTaskUnblockTime>
    1744:	41 c0       	rjmp	.+130    	; 0x17c8 <xTaskIncrementTick+0x118>
    1746:	e0 91 f8 06 	lds	r30, 0x06F8	; 0x8006f8 <pxDelayedTaskList>
    174a:	f0 91 f9 06 	lds	r31, 0x06F9	; 0x8006f9 <pxDelayedTaskList+0x1>
    174e:	05 80       	ldd	r0, Z+5	; 0x05
    1750:	f6 81       	ldd	r31, Z+6	; 0x06
    1752:	e0 2d       	mov	r30, r0
    1754:	c6 81       	ldd	r28, Z+6	; 0x06
    1756:	d7 81       	ldd	r29, Z+7	; 0x07
    1758:	8a 81       	ldd	r24, Y+2	; 0x02
    175a:	9b 81       	ldd	r25, Y+3	; 0x03
    175c:	e8 16       	cp	r14, r24
    175e:	f9 06       	cpc	r15, r25
    1760:	28 f4       	brcc	.+10     	; 0x176c <xTaskIncrementTick+0xbc>
    1762:	90 93 d0 06 	sts	0x06D0, r25	; 0x8006d0 <xNextTaskUnblockTime+0x1>
    1766:	80 93 cf 06 	sts	0x06CF, r24	; 0x8006cf <xNextTaskUnblockTime>
    176a:	2e c0       	rjmp	.+92     	; 0x17c8 <xTaskIncrementTick+0x118>
    176c:	8e 01       	movw	r16, r28
    176e:	0e 5f       	subi	r16, 0xFE	; 254
    1770:	1f 4f       	sbci	r17, 0xFF	; 255
    1772:	c8 01       	movw	r24, r16
    1774:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    1778:	8c 89       	ldd	r24, Y+20	; 0x14
    177a:	9d 89       	ldd	r25, Y+21	; 0x15
    177c:	89 2b       	or	r24, r25
    177e:	21 f0       	breq	.+8      	; 0x1788 <xTaskIncrementTick+0xd8>
    1780:	ce 01       	movw	r24, r28
    1782:	0c 96       	adiw	r24, 0x0c	; 12
    1784:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    1788:	8e 89       	ldd	r24, Y+22	; 0x16
    178a:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <uxTopReadyPriority>
    178e:	98 17       	cp	r25, r24
    1790:	10 f4       	brcc	.+4      	; 0x1796 <xTaskIncrementTick+0xe6>
    1792:	80 93 d6 06 	sts	0x06D6, r24	; 0x8006d6 <uxTopReadyPriority>
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	9c 01       	movw	r18, r24
    179a:	22 0f       	add	r18, r18
    179c:	33 1f       	adc	r19, r19
    179e:	22 0f       	add	r18, r18
    17a0:	33 1f       	adc	r19, r19
    17a2:	22 0f       	add	r18, r18
    17a4:	33 1f       	adc	r19, r19
    17a6:	82 0f       	add	r24, r18
    17a8:	93 1f       	adc	r25, r19
    17aa:	b8 01       	movw	r22, r16
    17ac:	84 5f       	subi	r24, 0xF4	; 244
    17ae:	98 4f       	sbci	r25, 0xF8	; 248
    17b0:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <vListInsertEnd>
    17b4:	9e 89       	ldd	r25, Y+22	; 0x16
    17b6:	e0 91 30 07 	lds	r30, 0x0730	; 0x800730 <pxCurrentTCB>
    17ba:	f0 91 31 07 	lds	r31, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    17be:	86 89       	ldd	r24, Z+22	; 0x16
    17c0:	98 17       	cp	r25, r24
    17c2:	08 f0       	brcs	.+2      	; 0x17c6 <xTaskIncrementTick+0x116>
    17c4:	ae cf       	rjmp	.-164    	; 0x1722 <xTaskIncrementTick+0x72>
    17c6:	b1 cf       	rjmp	.-158    	; 0x172a <xTaskIncrementTick+0x7a>
    17c8:	e0 91 30 07 	lds	r30, 0x0730	; 0x800730 <pxCurrentTCB>
    17cc:	f0 91 31 07 	lds	r31, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    17d0:	86 89       	ldd	r24, Z+22	; 0x16
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	fc 01       	movw	r30, r24
    17d6:	ee 0f       	add	r30, r30
    17d8:	ff 1f       	adc	r31, r31
    17da:	ee 0f       	add	r30, r30
    17dc:	ff 1f       	adc	r31, r31
    17de:	ee 0f       	add	r30, r30
    17e0:	ff 1f       	adc	r31, r31
    17e2:	8e 0f       	add	r24, r30
    17e4:	9f 1f       	adc	r25, r31
    17e6:	fc 01       	movw	r30, r24
    17e8:	e4 5f       	subi	r30, 0xF4	; 244
    17ea:	f8 4f       	sbci	r31, 0xF8	; 248
    17ec:	80 81       	ld	r24, Z
    17ee:	82 30       	cpi	r24, 0x02	; 2
    17f0:	40 f4       	brcc	.+16     	; 0x1802 <xTaskIncrementTick+0x152>
    17f2:	09 c0       	rjmp	.+18     	; 0x1806 <xTaskIncrementTick+0x156>
    17f4:	80 91 d4 06 	lds	r24, 0x06D4	; 0x8006d4 <uxPendedTicks>
    17f8:	8f 5f       	subi	r24, 0xFF	; 255
    17fa:	80 93 d4 06 	sts	0x06D4, r24	; 0x8006d4 <uxPendedTicks>
    17fe:	d1 2c       	mov	r13, r1
    1800:	02 c0       	rjmp	.+4      	; 0x1806 <xTaskIncrementTick+0x156>
    1802:	dd 24       	eor	r13, r13
    1804:	d3 94       	inc	r13
    1806:	80 91 d3 06 	lds	r24, 0x06D3	; 0x8006d3 <xYieldPending>
    180a:	88 23       	and	r24, r24
    180c:	11 f0       	breq	.+4      	; 0x1812 <xTaskIncrementTick+0x162>
    180e:	dd 24       	eor	r13, r13
    1810:	d3 94       	inc	r13
    1812:	8d 2d       	mov	r24, r13
    1814:	df 91       	pop	r29
    1816:	cf 91       	pop	r28
    1818:	1f 91       	pop	r17
    181a:	0f 91       	pop	r16
    181c:	ff 90       	pop	r15
    181e:	ef 90       	pop	r14
    1820:	df 90       	pop	r13
    1822:	08 95       	ret

00001824 <xTaskResumeAll>:
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	f8 94       	cli
    1830:	0f 92       	push	r0
    1832:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <uxSchedulerSuspended>
    1836:	81 50       	subi	r24, 0x01	; 1
    1838:	80 93 cc 06 	sts	0x06CC, r24	; 0x8006cc <uxSchedulerSuspended>
    183c:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <uxSchedulerSuspended>
    1840:	81 11       	cpse	r24, r1
    1842:	58 c0       	rjmp	.+176    	; 0x18f4 <xTaskResumeAll+0xd0>
    1844:	80 91 d9 06 	lds	r24, 0x06D9	; 0x8006d9 <uxCurrentNumberOfTasks>
    1848:	81 11       	cpse	r24, r1
    184a:	33 c0       	rjmp	.+102    	; 0x18b2 <xTaskResumeAll+0x8e>
    184c:	56 c0       	rjmp	.+172    	; 0x18fa <xTaskResumeAll+0xd6>
    184e:	e0 91 f2 06 	lds	r30, 0x06F2	; 0x8006f2 <xPendingReadyList+0x5>
    1852:	f0 91 f3 06 	lds	r31, 0x06F3	; 0x8006f3 <xPendingReadyList+0x6>
    1856:	c6 81       	ldd	r28, Z+6	; 0x06
    1858:	d7 81       	ldd	r29, Z+7	; 0x07
    185a:	ce 01       	movw	r24, r28
    185c:	0c 96       	adiw	r24, 0x0c	; 12
    185e:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    1862:	8e 01       	movw	r16, r28
    1864:	0e 5f       	subi	r16, 0xFE	; 254
    1866:	1f 4f       	sbci	r17, 0xFF	; 255
    1868:	c8 01       	movw	r24, r16
    186a:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    186e:	8e 89       	ldd	r24, Y+22	; 0x16
    1870:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <uxTopReadyPriority>
    1874:	98 17       	cp	r25, r24
    1876:	10 f4       	brcc	.+4      	; 0x187c <xTaskResumeAll+0x58>
    1878:	80 93 d6 06 	sts	0x06D6, r24	; 0x8006d6 <uxTopReadyPriority>
    187c:	90 e0       	ldi	r25, 0x00	; 0
    187e:	9c 01       	movw	r18, r24
    1880:	22 0f       	add	r18, r18
    1882:	33 1f       	adc	r19, r19
    1884:	22 0f       	add	r18, r18
    1886:	33 1f       	adc	r19, r19
    1888:	22 0f       	add	r18, r18
    188a:	33 1f       	adc	r19, r19
    188c:	82 0f       	add	r24, r18
    188e:	93 1f       	adc	r25, r19
    1890:	b8 01       	movw	r22, r16
    1892:	84 5f       	subi	r24, 0xF4	; 244
    1894:	98 4f       	sbci	r25, 0xF8	; 248
    1896:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <vListInsertEnd>
    189a:	9e 89       	ldd	r25, Y+22	; 0x16
    189c:	e0 91 30 07 	lds	r30, 0x0730	; 0x800730 <pxCurrentTCB>
    18a0:	f0 91 31 07 	lds	r31, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    18a4:	86 89       	ldd	r24, Z+22	; 0x16
    18a6:	98 17       	cp	r25, r24
    18a8:	30 f0       	brcs	.+12     	; 0x18b6 <xTaskResumeAll+0x92>
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	80 93 d3 06 	sts	0x06D3, r24	; 0x8006d3 <xYieldPending>
    18b0:	02 c0       	rjmp	.+4      	; 0x18b6 <xTaskResumeAll+0x92>
    18b2:	c0 e0       	ldi	r28, 0x00	; 0
    18b4:	d0 e0       	ldi	r29, 0x00	; 0
    18b6:	80 91 ed 06 	lds	r24, 0x06ED	; 0x8006ed <xPendingReadyList>
    18ba:	81 11       	cpse	r24, r1
    18bc:	c8 cf       	rjmp	.-112    	; 0x184e <xTaskResumeAll+0x2a>
    18be:	cd 2b       	or	r28, r29
    18c0:	11 f0       	breq	.+4      	; 0x18c6 <xTaskResumeAll+0xa2>
    18c2:	0e 94 23 09 	call	0x1246	; 0x1246 <prvResetNextTaskUnblockTime>
    18c6:	c0 91 d4 06 	lds	r28, 0x06D4	; 0x8006d4 <uxPendedTicks>
    18ca:	cc 23       	and	r28, r28
    18cc:	59 f0       	breq	.+22     	; 0x18e4 <xTaskResumeAll+0xc0>
    18ce:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <xTaskIncrementTick>
    18d2:	88 23       	and	r24, r24
    18d4:	19 f0       	breq	.+6      	; 0x18dc <xTaskResumeAll+0xb8>
    18d6:	81 e0       	ldi	r24, 0x01	; 1
    18d8:	80 93 d3 06 	sts	0x06D3, r24	; 0x8006d3 <xYieldPending>
    18dc:	c1 50       	subi	r28, 0x01	; 1
    18de:	b9 f7       	brne	.-18     	; 0x18ce <xTaskResumeAll+0xaa>
    18e0:	10 92 d4 06 	sts	0x06D4, r1	; 0x8006d4 <uxPendedTicks>
    18e4:	80 91 d3 06 	lds	r24, 0x06D3	; 0x8006d3 <xYieldPending>
    18e8:	88 23       	and	r24, r24
    18ea:	31 f0       	breq	.+12     	; 0x18f8 <xTaskResumeAll+0xd4>
    18ec:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
    18f0:	81 e0       	ldi	r24, 0x01	; 1
    18f2:	03 c0       	rjmp	.+6      	; 0x18fa <xTaskResumeAll+0xd6>
    18f4:	80 e0       	ldi	r24, 0x00	; 0
    18f6:	01 c0       	rjmp	.+2      	; 0x18fa <xTaskResumeAll+0xd6>
    18f8:	80 e0       	ldi	r24, 0x00	; 0
    18fa:	0f 90       	pop	r0
    18fc:	0f be       	out	0x3f, r0	; 63
    18fe:	df 91       	pop	r29
    1900:	cf 91       	pop	r28
    1902:	1f 91       	pop	r17
    1904:	0f 91       	pop	r16
    1906:	08 95       	ret

00001908 <vTaskDelay>:
    1908:	cf 93       	push	r28
    190a:	df 93       	push	r29
    190c:	ec 01       	movw	r28, r24
    190e:	89 2b       	or	r24, r25
    1910:	49 f0       	breq	.+18     	; 0x1924 <vTaskDelay+0x1c>
    1912:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <vTaskSuspendAll>
    1916:	60 e0       	ldi	r22, 0x00	; 0
    1918:	ce 01       	movw	r24, r28
    191a:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvAddCurrentTaskToDelayedList>
    191e:	0e 94 12 0c 	call	0x1824	; 0x1824 <xTaskResumeAll>
    1922:	01 c0       	rjmp	.+2      	; 0x1926 <vTaskDelay+0x1e>
    1924:	80 e0       	ldi	r24, 0x00	; 0
    1926:	81 11       	cpse	r24, r1
    1928:	02 c0       	rjmp	.+4      	; 0x192e <vTaskDelay+0x26>
    192a:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
    192e:	df 91       	pop	r29
    1930:	cf 91       	pop	r28
    1932:	08 95       	ret

00001934 <vTaskSwitchContext>:
    1934:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <uxSchedulerSuspended>
    1938:	88 23       	and	r24, r24
    193a:	21 f0       	breq	.+8      	; 0x1944 <vTaskSwitchContext+0x10>
    193c:	81 e0       	ldi	r24, 0x01	; 1
    193e:	80 93 d3 06 	sts	0x06D3, r24	; 0x8006d3 <xYieldPending>
    1942:	08 95       	ret
    1944:	10 92 d3 06 	sts	0x06D3, r1	; 0x8006d3 <xYieldPending>
    1948:	20 91 d6 06 	lds	r18, 0x06D6	; 0x8006d6 <uxTopReadyPriority>
    194c:	01 c0       	rjmp	.+2      	; 0x1950 <vTaskSwitchContext+0x1c>
    194e:	21 50       	subi	r18, 0x01	; 1
    1950:	82 2f       	mov	r24, r18
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	fc 01       	movw	r30, r24
    1956:	ee 0f       	add	r30, r30
    1958:	ff 1f       	adc	r31, r31
    195a:	ee 0f       	add	r30, r30
    195c:	ff 1f       	adc	r31, r31
    195e:	ee 0f       	add	r30, r30
    1960:	ff 1f       	adc	r31, r31
    1962:	e8 0f       	add	r30, r24
    1964:	f9 1f       	adc	r31, r25
    1966:	e4 5f       	subi	r30, 0xF4	; 244
    1968:	f8 4f       	sbci	r31, 0xF8	; 248
    196a:	30 81       	ld	r19, Z
    196c:	33 23       	and	r19, r19
    196e:	79 f3       	breq	.-34     	; 0x194e <vTaskSwitchContext+0x1a>
    1970:	ac 01       	movw	r20, r24
    1972:	44 0f       	add	r20, r20
    1974:	55 1f       	adc	r21, r21
    1976:	44 0f       	add	r20, r20
    1978:	55 1f       	adc	r21, r21
    197a:	44 0f       	add	r20, r20
    197c:	55 1f       	adc	r21, r21
    197e:	48 0f       	add	r20, r24
    1980:	59 1f       	adc	r21, r25
    1982:	df 01       	movw	r26, r30
    1984:	01 80       	ldd	r0, Z+1	; 0x01
    1986:	f2 81       	ldd	r31, Z+2	; 0x02
    1988:	e0 2d       	mov	r30, r0
    198a:	02 80       	ldd	r0, Z+2	; 0x02
    198c:	f3 81       	ldd	r31, Z+3	; 0x03
    198e:	e0 2d       	mov	r30, r0
    1990:	12 96       	adiw	r26, 0x02	; 2
    1992:	fc 93       	st	X, r31
    1994:	ee 93       	st	-X, r30
    1996:	11 97       	sbiw	r26, 0x01	; 1
    1998:	41 5f       	subi	r20, 0xF1	; 241
    199a:	58 4f       	sbci	r21, 0xF8	; 248
    199c:	e4 17       	cp	r30, r20
    199e:	f5 07       	cpc	r31, r21
    19a0:	29 f4       	brne	.+10     	; 0x19ac <vTaskSwitchContext+0x78>
    19a2:	42 81       	ldd	r20, Z+2	; 0x02
    19a4:	53 81       	ldd	r21, Z+3	; 0x03
    19a6:	fd 01       	movw	r30, r26
    19a8:	52 83       	std	Z+2, r21	; 0x02
    19aa:	41 83       	std	Z+1, r20	; 0x01
    19ac:	fc 01       	movw	r30, r24
    19ae:	ee 0f       	add	r30, r30
    19b0:	ff 1f       	adc	r31, r31
    19b2:	ee 0f       	add	r30, r30
    19b4:	ff 1f       	adc	r31, r31
    19b6:	ee 0f       	add	r30, r30
    19b8:	ff 1f       	adc	r31, r31
    19ba:	8e 0f       	add	r24, r30
    19bc:	9f 1f       	adc	r25, r31
    19be:	fc 01       	movw	r30, r24
    19c0:	e4 5f       	subi	r30, 0xF4	; 244
    19c2:	f8 4f       	sbci	r31, 0xF8	; 248
    19c4:	01 80       	ldd	r0, Z+1	; 0x01
    19c6:	f2 81       	ldd	r31, Z+2	; 0x02
    19c8:	e0 2d       	mov	r30, r0
    19ca:	86 81       	ldd	r24, Z+6	; 0x06
    19cc:	97 81       	ldd	r25, Z+7	; 0x07
    19ce:	90 93 31 07 	sts	0x0731, r25	; 0x800731 <pxCurrentTCB+0x1>
    19d2:	80 93 30 07 	sts	0x0730, r24	; 0x800730 <pxCurrentTCB>
    19d6:	20 93 d6 06 	sts	0x06D6, r18	; 0x8006d6 <uxTopReadyPriority>
    19da:	08 95       	ret

000019dc <vTaskSuspend>:
    19dc:	0f 93       	push	r16
    19de:	1f 93       	push	r17
    19e0:	cf 93       	push	r28
    19e2:	df 93       	push	r29
    19e4:	ec 01       	movw	r28, r24
    19e6:	0f b6       	in	r0, 0x3f	; 63
    19e8:	f8 94       	cli
    19ea:	0f 92       	push	r0
    19ec:	89 2b       	or	r24, r25
    19ee:	21 f4       	brne	.+8      	; 0x19f8 <vTaskSuspend+0x1c>
    19f0:	c0 91 30 07 	lds	r28, 0x0730	; 0x800730 <pxCurrentTCB>
    19f4:	d0 91 31 07 	lds	r29, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    19f8:	8e 01       	movw	r16, r28
    19fa:	0e 5f       	subi	r16, 0xFE	; 254
    19fc:	1f 4f       	sbci	r17, 0xFF	; 255
    19fe:	c8 01       	movw	r24, r16
    1a00:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    1a04:	8c 89       	ldd	r24, Y+20	; 0x14
    1a06:	9d 89       	ldd	r25, Y+21	; 0x15
    1a08:	89 2b       	or	r24, r25
    1a0a:	21 f0       	breq	.+8      	; 0x1a14 <vTaskSuspend+0x38>
    1a0c:	ce 01       	movw	r24, r28
    1a0e:	0c 96       	adiw	r24, 0x0c	; 12
    1a10:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    1a14:	b8 01       	movw	r22, r16
    1a16:	8a ed       	ldi	r24, 0xDA	; 218
    1a18:	96 e0       	ldi	r25, 0x06	; 6
    1a1a:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <vListInsertEnd>
    1a1e:	8d a1       	ldd	r24, Y+37	; 0x25
    1a20:	81 30       	cpi	r24, 0x01	; 1
    1a22:	09 f4       	brne	.+2      	; 0x1a26 <vTaskSuspend+0x4a>
    1a24:	1d a2       	std	Y+37, r1	; 0x25
    1a26:	0f 90       	pop	r0
    1a28:	0f be       	out	0x3f, r0	; 63
    1a2a:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <xSchedulerRunning>
    1a2e:	88 23       	and	r24, r24
    1a30:	39 f0       	breq	.+14     	; 0x1a40 <vTaskSuspend+0x64>
    1a32:	0f b6       	in	r0, 0x3f	; 63
    1a34:	f8 94       	cli
    1a36:	0f 92       	push	r0
    1a38:	0e 94 23 09 	call	0x1246	; 0x1246 <prvResetNextTaskUnblockTime>
    1a3c:	0f 90       	pop	r0
    1a3e:	0f be       	out	0x3f, r0	; 63
    1a40:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <pxCurrentTCB>
    1a44:	90 91 31 07 	lds	r25, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    1a48:	c8 17       	cp	r28, r24
    1a4a:	d9 07       	cpc	r29, r25
    1a4c:	a1 f4       	brne	.+40     	; 0x1a76 <vTaskSuspend+0x9a>
    1a4e:	80 91 d5 06 	lds	r24, 0x06D5	; 0x8006d5 <xSchedulerRunning>
    1a52:	88 23       	and	r24, r24
    1a54:	19 f0       	breq	.+6      	; 0x1a5c <vTaskSuspend+0x80>
    1a56:	0e 94 15 06 	call	0xc2a	; 0xc2a <vPortYield>
    1a5a:	0d c0       	rjmp	.+26     	; 0x1a76 <vTaskSuspend+0x9a>
    1a5c:	90 91 da 06 	lds	r25, 0x06DA	; 0x8006da <xSuspendedTaskList>
    1a60:	80 91 d9 06 	lds	r24, 0x06D9	; 0x8006d9 <uxCurrentNumberOfTasks>
    1a64:	98 13       	cpse	r25, r24
    1a66:	05 c0       	rjmp	.+10     	; 0x1a72 <vTaskSuspend+0x96>
    1a68:	10 92 31 07 	sts	0x0731, r1	; 0x800731 <pxCurrentTCB+0x1>
    1a6c:	10 92 30 07 	sts	0x0730, r1	; 0x800730 <pxCurrentTCB>
    1a70:	02 c0       	rjmp	.+4      	; 0x1a76 <vTaskSuspend+0x9a>
    1a72:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vTaskSwitchContext>
    1a76:	df 91       	pop	r29
    1a78:	cf 91       	pop	r28
    1a7a:	1f 91       	pop	r17
    1a7c:	0f 91       	pop	r16
    1a7e:	08 95       	ret

00001a80 <vTaskPlaceOnEventList>:
    1a80:	cf 93       	push	r28
    1a82:	df 93       	push	r29
    1a84:	eb 01       	movw	r28, r22
    1a86:	60 91 30 07 	lds	r22, 0x0730	; 0x800730 <pxCurrentTCB>
    1a8a:	70 91 31 07 	lds	r23, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    1a8e:	64 5f       	subi	r22, 0xF4	; 244
    1a90:	7f 4f       	sbci	r23, 0xFF	; 255
    1a92:	0e 94 19 05 	call	0xa32	; 0xa32 <vListInsert>
    1a96:	61 e0       	ldi	r22, 0x01	; 1
    1a98:	ce 01       	movw	r24, r28
    1a9a:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <prvAddCurrentTaskToDelayedList>
    1a9e:	df 91       	pop	r29
    1aa0:	cf 91       	pop	r28
    1aa2:	08 95       	ret

00001aa4 <xTaskRemoveFromEventList>:
    1aa4:	0f 93       	push	r16
    1aa6:	1f 93       	push	r17
    1aa8:	cf 93       	push	r28
    1aaa:	df 93       	push	r29
    1aac:	dc 01       	movw	r26, r24
    1aae:	15 96       	adiw	r26, 0x05	; 5
    1ab0:	ed 91       	ld	r30, X+
    1ab2:	fc 91       	ld	r31, X
    1ab4:	16 97       	sbiw	r26, 0x06	; 6
    1ab6:	c6 81       	ldd	r28, Z+6	; 0x06
    1ab8:	d7 81       	ldd	r29, Z+7	; 0x07
    1aba:	8e 01       	movw	r16, r28
    1abc:	04 5f       	subi	r16, 0xF4	; 244
    1abe:	1f 4f       	sbci	r17, 0xFF	; 255
    1ac0:	c8 01       	movw	r24, r16
    1ac2:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    1ac6:	80 91 cc 06 	lds	r24, 0x06CC	; 0x8006cc <uxSchedulerSuspended>
    1aca:	81 11       	cpse	r24, r1
    1acc:	1c c0       	rjmp	.+56     	; 0x1b06 <xTaskRemoveFromEventList+0x62>
    1ace:	0a 50       	subi	r16, 0x0A	; 10
    1ad0:	11 09       	sbc	r17, r1
    1ad2:	c8 01       	movw	r24, r16
    1ad4:	0e 94 4a 05 	call	0xa94	; 0xa94 <uxListRemove>
    1ad8:	8e 89       	ldd	r24, Y+22	; 0x16
    1ada:	90 91 d6 06 	lds	r25, 0x06D6	; 0x8006d6 <uxTopReadyPriority>
    1ade:	98 17       	cp	r25, r24
    1ae0:	10 f4       	brcc	.+4      	; 0x1ae6 <xTaskRemoveFromEventList+0x42>
    1ae2:	80 93 d6 06 	sts	0x06D6, r24	; 0x8006d6 <uxTopReadyPriority>
    1ae6:	90 e0       	ldi	r25, 0x00	; 0
    1ae8:	9c 01       	movw	r18, r24
    1aea:	22 0f       	add	r18, r18
    1aec:	33 1f       	adc	r19, r19
    1aee:	22 0f       	add	r18, r18
    1af0:	33 1f       	adc	r19, r19
    1af2:	22 0f       	add	r18, r18
    1af4:	33 1f       	adc	r19, r19
    1af6:	82 0f       	add	r24, r18
    1af8:	93 1f       	adc	r25, r19
    1afa:	b8 01       	movw	r22, r16
    1afc:	84 5f       	subi	r24, 0xF4	; 244
    1afe:	98 4f       	sbci	r25, 0xF8	; 248
    1b00:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <vListInsertEnd>
    1b04:	05 c0       	rjmp	.+10     	; 0x1b10 <xTaskRemoveFromEventList+0x6c>
    1b06:	b8 01       	movw	r22, r16
    1b08:	8d ee       	ldi	r24, 0xED	; 237
    1b0a:	96 e0       	ldi	r25, 0x06	; 6
    1b0c:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <vListInsertEnd>
    1b10:	9e 89       	ldd	r25, Y+22	; 0x16
    1b12:	e0 91 30 07 	lds	r30, 0x0730	; 0x800730 <pxCurrentTCB>
    1b16:	f0 91 31 07 	lds	r31, 0x0731	; 0x800731 <pxCurrentTCB+0x1>
    1b1a:	86 89       	ldd	r24, Z+22	; 0x16
    1b1c:	89 17       	cp	r24, r25
    1b1e:	20 f4       	brcc	.+8      	; 0x1b28 <xTaskRemoveFromEventList+0x84>
    1b20:	81 e0       	ldi	r24, 0x01	; 1
    1b22:	80 93 d3 06 	sts	0x06D3, r24	; 0x8006d3 <xYieldPending>
    1b26:	01 c0       	rjmp	.+2      	; 0x1b2a <xTaskRemoveFromEventList+0x86>
    1b28:	80 e0       	ldi	r24, 0x00	; 0
    1b2a:	df 91       	pop	r29
    1b2c:	cf 91       	pop	r28
    1b2e:	1f 91       	pop	r17
    1b30:	0f 91       	pop	r16
    1b32:	08 95       	ret

00001b34 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1b34:	20 91 d2 06 	lds	r18, 0x06D2	; 0x8006d2 <xNumOfOverflows>
    1b38:	fc 01       	movw	r30, r24
    1b3a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1b3c:	20 91 d7 06 	lds	r18, 0x06D7	; 0x8006d7 <xTickCount>
    1b40:	30 91 d8 06 	lds	r19, 0x06D8	; 0x8006d8 <xTickCount+0x1>
    1b44:	32 83       	std	Z+2, r19	; 0x02
    1b46:	21 83       	std	Z+1, r18	; 0x01
    1b48:	08 95       	ret

00001b4a <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    1b4a:	1f 93       	push	r17
    1b4c:	cf 93       	push	r28
    1b4e:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	f8 94       	cli
    1b54:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1b56:	e0 91 d7 06 	lds	r30, 0x06D7	; 0x8006d7 <xTickCount>
    1b5a:	f0 91 d8 06 	lds	r31, 0x06D8	; 0x8006d8 <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    1b5e:	dc 01       	movw	r26, r24
    1b60:	11 96       	adiw	r26, 0x01	; 1
    1b62:	4d 91       	ld	r20, X+
    1b64:	5c 91       	ld	r21, X
    1b66:	12 97       	sbiw	r26, 0x02	; 2
    1b68:	df 01       	movw	r26, r30
    1b6a:	a4 1b       	sub	r26, r20
    1b6c:	b5 0b       	sbc	r27, r21
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    1b6e:	eb 01       	movw	r28, r22
    1b70:	28 81       	ld	r18, Y
    1b72:	39 81       	ldd	r19, Y+1	; 0x01
    1b74:	2f 3f       	cpi	r18, 0xFF	; 255
    1b76:	df ef       	ldi	r29, 0xFF	; 255
    1b78:	3d 07       	cpc	r19, r29
    1b7a:	d1 f0       	breq	.+52     	; 0x1bb0 <xTaskCheckForTimeOut+0x66>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1b7c:	ec 01       	movw	r28, r24
    1b7e:	18 81       	ld	r17, Y
    1b80:	c0 91 d2 06 	lds	r28, 0x06D2	; 0x8006d2 <xNumOfOverflows>
    1b84:	1c 17       	cp	r17, r28
    1b86:	19 f0       	breq	.+6      	; 0x1b8e <xTaskCheckForTimeOut+0x44>
    1b88:	e4 17       	cp	r30, r20
    1b8a:	f5 07       	cpc	r31, r21
    1b8c:	98 f4       	brcc	.+38     	; 0x1bb4 <xTaskCheckForTimeOut+0x6a>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    1b8e:	a2 17       	cp	r26, r18
    1b90:	b3 07       	cpc	r27, r19
    1b92:	48 f4       	brcc	.+18     	; 0x1ba6 <xTaskCheckForTimeOut+0x5c>
    1b94:	fb 01       	movw	r30, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    1b96:	2a 1b       	sub	r18, r26
    1b98:	3b 0b       	sbc	r19, r27
    1b9a:	31 83       	std	Z+1, r19	; 0x01
    1b9c:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
    1b9e:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    1ba2:	80 e0       	ldi	r24, 0x00	; 0
    1ba4:	08 c0       	rjmp	.+16     	; 0x1bb6 <xTaskCheckForTimeOut+0x6c>
		}
		else
		{
			*pxTicksToWait = 0;
    1ba6:	fb 01       	movw	r30, r22
    1ba8:	11 82       	std	Z+1, r1	; 0x01
    1baa:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    1bac:	81 e0       	ldi	r24, 0x01	; 1
    1bae:	03 c0       	rjmp	.+6      	; 0x1bb6 <xTaskCheckForTimeOut+0x6c>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
    1bb2:	01 c0       	rjmp	.+2      	; 0x1bb6 <xTaskCheckForTimeOut+0x6c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    1bb4:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    1bb6:	0f 90       	pop	r0
    1bb8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1bba:	df 91       	pop	r29
    1bbc:	cf 91       	pop	r28
    1bbe:	1f 91       	pop	r17
    1bc0:	08 95       	ret

00001bc2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	80 93 d3 06 	sts	0x06D3, r24	; 0x8006d3 <xYieldPending>
    1bc8:	08 95       	ret

00001bca <__udivmodsi4>:
    1bca:	a1 e2       	ldi	r26, 0x21	; 33
    1bcc:	1a 2e       	mov	r1, r26
    1bce:	aa 1b       	sub	r26, r26
    1bd0:	bb 1b       	sub	r27, r27
    1bd2:	fd 01       	movw	r30, r26
    1bd4:	0d c0       	rjmp	.+26     	; 0x1bf0 <__udivmodsi4_ep>

00001bd6 <__udivmodsi4_loop>:
    1bd6:	aa 1f       	adc	r26, r26
    1bd8:	bb 1f       	adc	r27, r27
    1bda:	ee 1f       	adc	r30, r30
    1bdc:	ff 1f       	adc	r31, r31
    1bde:	a2 17       	cp	r26, r18
    1be0:	b3 07       	cpc	r27, r19
    1be2:	e4 07       	cpc	r30, r20
    1be4:	f5 07       	cpc	r31, r21
    1be6:	20 f0       	brcs	.+8      	; 0x1bf0 <__udivmodsi4_ep>
    1be8:	a2 1b       	sub	r26, r18
    1bea:	b3 0b       	sbc	r27, r19
    1bec:	e4 0b       	sbc	r30, r20
    1bee:	f5 0b       	sbc	r31, r21

00001bf0 <__udivmodsi4_ep>:
    1bf0:	66 1f       	adc	r22, r22
    1bf2:	77 1f       	adc	r23, r23
    1bf4:	88 1f       	adc	r24, r24
    1bf6:	99 1f       	adc	r25, r25
    1bf8:	1a 94       	dec	r1
    1bfa:	69 f7       	brne	.-38     	; 0x1bd6 <__udivmodsi4_loop>
    1bfc:	60 95       	com	r22
    1bfe:	70 95       	com	r23
    1c00:	80 95       	com	r24
    1c02:	90 95       	com	r25
    1c04:	9b 01       	movw	r18, r22
    1c06:	ac 01       	movw	r20, r24
    1c08:	bd 01       	movw	r22, r26
    1c0a:	cf 01       	movw	r24, r30
    1c0c:	08 95       	ret

00001c0e <__umulhisi3>:
    1c0e:	a2 9f       	mul	r26, r18
    1c10:	b0 01       	movw	r22, r0
    1c12:	b3 9f       	mul	r27, r19
    1c14:	c0 01       	movw	r24, r0
    1c16:	a3 9f       	mul	r26, r19
    1c18:	70 0d       	add	r23, r0
    1c1a:	81 1d       	adc	r24, r1
    1c1c:	11 24       	eor	r1, r1
    1c1e:	91 1d       	adc	r25, r1
    1c20:	b2 9f       	mul	r27, r18
    1c22:	70 0d       	add	r23, r0
    1c24:	81 1d       	adc	r24, r1
    1c26:	11 24       	eor	r1, r1
    1c28:	91 1d       	adc	r25, r1
    1c2a:	08 95       	ret

00001c2c <__muluhisi3>:
    1c2c:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <__umulhisi3>
    1c30:	a5 9f       	mul	r26, r21
    1c32:	90 0d       	add	r25, r0
    1c34:	b4 9f       	mul	r27, r20
    1c36:	90 0d       	add	r25, r0
    1c38:	a4 9f       	mul	r26, r20
    1c3a:	80 0d       	add	r24, r0
    1c3c:	91 1d       	adc	r25, r1
    1c3e:	11 24       	eor	r1, r1
    1c40:	08 95       	ret

00001c42 <memcpy>:
    1c42:	fb 01       	movw	r30, r22
    1c44:	dc 01       	movw	r26, r24
    1c46:	02 c0       	rjmp	.+4      	; 0x1c4c <memcpy+0xa>
    1c48:	01 90       	ld	r0, Z+
    1c4a:	0d 92       	st	X+, r0
    1c4c:	41 50       	subi	r20, 0x01	; 1
    1c4e:	50 40       	sbci	r21, 0x00	; 0
    1c50:	d8 f7       	brcc	.-10     	; 0x1c48 <memcpy+0x6>
    1c52:	08 95       	ret

00001c54 <_exit>:
    1c54:	f8 94       	cli

00001c56 <__stop_program>:
    1c56:	ff cf       	rjmp	.-2      	; 0x1c56 <__stop_program>
